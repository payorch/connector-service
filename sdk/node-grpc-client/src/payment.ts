// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: payment.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "ucs.payments";

export enum EventType {
  PAYMENT = 0,
  REFUND = 1,
  UNRECOGNIZED = -1,
}

export function eventTypeFromJSON(object: any): EventType {
  switch (object) {
    case 0:
    case "PAYMENT":
      return EventType.PAYMENT;
    case 1:
    case "REFUND":
      return EventType.REFUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EventType.UNRECOGNIZED;
  }
}

export function eventTypeToJSON(object: EventType): string {
  switch (object) {
    case EventType.PAYMENT:
      return "PAYMENT";
    case EventType.REFUND:
      return "REFUND";
    case EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Connector {
  ADYENPLATFORM = 0,
  ACI = 1,
  ADYEN = 2,
  AIRWALLEX = 3,
  AUTHORIZEDOTNET = 4,
  BAMBORA = 5,
  BAMBORAAPAC = 6,
  BANKOFAMERICA = 7,
  BILLWERK = 8,
  BITPAY = 9,
  BLUESNAP = 10,
  BOKU = 11,
  BRAINTREE = 12,
  CASHTOCODE = 13,
  CHARGEBEE = 14,
  CHECKOUT = 15,
  COINBASE = 16,
  COINGATE = 17,
  CRYPTOPAY = 18,
  CTP_MASTERCARD = 19,
  CTP_VISA = 20,
  CYBERSOURCE = 21,
  DATATRANS = 22,
  DEUTSCHEBANK = 23,
  DIGITALVIRGO = 24,
  DLOCAL = 25,
  EBANX = 26,
  ELAVON = 27,
  FISERV = 28,
  FISERVEMEA = 29,
  FIUU = 30,
  FORTE = 31,
  GETNET = 32,
  GLOBALPAY = 33,
  GLOBEPAY = 34,
  GOCARDLESS = 35,
  GPAYMENTS = 36,
  HIPAY = 37,
  HELCIM = 38,
  INESPAY = 39,
  IATAPAY = 40,
  ITAUBANK = 41,
  JPMORGAN = 42,
  JUSPAYTHREEDSSERVER = 43,
  KLARNA = 44,
  MIFINITY = 45,
  MOLLIE = 46,
  MONERIS = 47,
  MULTISAFEPAY = 48,
  NETCETERA = 49,
  NEXINETS = 50,
  NEXIXPAY = 51,
  NMI = 52,
  NOMUPAY = 53,
  NOON = 54,
  NOVALNET = 55,
  NUVEI = 56,
  OPENNODE = 57,
  PAYBOX = 58,
  PAYME = 59,
  PAYONE = 60,
  PAYPAL = 61,
  PAYSTACK = 62,
  PAYU = 63,
  PLACETOPAY = 64,
  POWERTRANZ = 65,
  PROPHETPAY = 66,
  RAPYD = 67,
  RAZORPAY = 68,
  RECURLY = 69,
  REDSYS = 70,
  SHIFT4 = 71,
  SQUARE = 72,
  STAX = 73,
  STRIPE = 74,
  TAXJAR = 75,
  THREEDSECUREIO = 76,
  TRUSTPAY = 77,
  TSYS = 78,
  VOLT = 79,
  WELLSFARGO = 80,
  WISE = 81,
  WORLDLINE = 82,
  WORLDPAY = 83,
  SIGNIFYD = 84,
  PLAID = 85,
  RISKIFIED = 86,
  XENDIT = 87,
  ZEN = 88,
  ZSL = 89,
  UNRECOGNIZED = -1,
}

export function connectorFromJSON(object: any): Connector {
  switch (object) {
    case 0:
    case "ADYENPLATFORM":
      return Connector.ADYENPLATFORM;
    case 1:
    case "ACI":
      return Connector.ACI;
    case 2:
    case "ADYEN":
      return Connector.ADYEN;
    case 3:
    case "AIRWALLEX":
      return Connector.AIRWALLEX;
    case 4:
    case "AUTHORIZEDOTNET":
      return Connector.AUTHORIZEDOTNET;
    case 5:
    case "BAMBORA":
      return Connector.BAMBORA;
    case 6:
    case "BAMBORAAPAC":
      return Connector.BAMBORAAPAC;
    case 7:
    case "BANKOFAMERICA":
      return Connector.BANKOFAMERICA;
    case 8:
    case "BILLWERK":
      return Connector.BILLWERK;
    case 9:
    case "BITPAY":
      return Connector.BITPAY;
    case 10:
    case "BLUESNAP":
      return Connector.BLUESNAP;
    case 11:
    case "BOKU":
      return Connector.BOKU;
    case 12:
    case "BRAINTREE":
      return Connector.BRAINTREE;
    case 13:
    case "CASHTOCODE":
      return Connector.CASHTOCODE;
    case 14:
    case "CHARGEBEE":
      return Connector.CHARGEBEE;
    case 15:
    case "CHECKOUT":
      return Connector.CHECKOUT;
    case 16:
    case "COINBASE":
      return Connector.COINBASE;
    case 17:
    case "COINGATE":
      return Connector.COINGATE;
    case 18:
    case "CRYPTOPAY":
      return Connector.CRYPTOPAY;
    case 19:
    case "CTP_MASTERCARD":
      return Connector.CTP_MASTERCARD;
    case 20:
    case "CTP_VISA":
      return Connector.CTP_VISA;
    case 21:
    case "CYBERSOURCE":
      return Connector.CYBERSOURCE;
    case 22:
    case "DATATRANS":
      return Connector.DATATRANS;
    case 23:
    case "DEUTSCHEBANK":
      return Connector.DEUTSCHEBANK;
    case 24:
    case "DIGITALVIRGO":
      return Connector.DIGITALVIRGO;
    case 25:
    case "DLOCAL":
      return Connector.DLOCAL;
    case 26:
    case "EBANX":
      return Connector.EBANX;
    case 27:
    case "ELAVON":
      return Connector.ELAVON;
    case 28:
    case "FISERV":
      return Connector.FISERV;
    case 29:
    case "FISERVEMEA":
      return Connector.FISERVEMEA;
    case 30:
    case "FIUU":
      return Connector.FIUU;
    case 31:
    case "FORTE":
      return Connector.FORTE;
    case 32:
    case "GETNET":
      return Connector.GETNET;
    case 33:
    case "GLOBALPAY":
      return Connector.GLOBALPAY;
    case 34:
    case "GLOBEPAY":
      return Connector.GLOBEPAY;
    case 35:
    case "GOCARDLESS":
      return Connector.GOCARDLESS;
    case 36:
    case "GPAYMENTS":
      return Connector.GPAYMENTS;
    case 37:
    case "HIPAY":
      return Connector.HIPAY;
    case 38:
    case "HELCIM":
      return Connector.HELCIM;
    case 39:
    case "INESPAY":
      return Connector.INESPAY;
    case 40:
    case "IATAPAY":
      return Connector.IATAPAY;
    case 41:
    case "ITAUBANK":
      return Connector.ITAUBANK;
    case 42:
    case "JPMORGAN":
      return Connector.JPMORGAN;
    case 43:
    case "JUSPAYTHREEDSSERVER":
      return Connector.JUSPAYTHREEDSSERVER;
    case 44:
    case "KLARNA":
      return Connector.KLARNA;
    case 45:
    case "MIFINITY":
      return Connector.MIFINITY;
    case 46:
    case "MOLLIE":
      return Connector.MOLLIE;
    case 47:
    case "MONERIS":
      return Connector.MONERIS;
    case 48:
    case "MULTISAFEPAY":
      return Connector.MULTISAFEPAY;
    case 49:
    case "NETCETERA":
      return Connector.NETCETERA;
    case 50:
    case "NEXINETS":
      return Connector.NEXINETS;
    case 51:
    case "NEXIXPAY":
      return Connector.NEXIXPAY;
    case 52:
    case "NMI":
      return Connector.NMI;
    case 53:
    case "NOMUPAY":
      return Connector.NOMUPAY;
    case 54:
    case "NOON":
      return Connector.NOON;
    case 55:
    case "NOVALNET":
      return Connector.NOVALNET;
    case 56:
    case "NUVEI":
      return Connector.NUVEI;
    case 57:
    case "OPENNODE":
      return Connector.OPENNODE;
    case 58:
    case "PAYBOX":
      return Connector.PAYBOX;
    case 59:
    case "PAYME":
      return Connector.PAYME;
    case 60:
    case "PAYONE":
      return Connector.PAYONE;
    case 61:
    case "PAYPAL":
      return Connector.PAYPAL;
    case 62:
    case "PAYSTACK":
      return Connector.PAYSTACK;
    case 63:
    case "PAYU":
      return Connector.PAYU;
    case 64:
    case "PLACETOPAY":
      return Connector.PLACETOPAY;
    case 65:
    case "POWERTRANZ":
      return Connector.POWERTRANZ;
    case 66:
    case "PROPHETPAY":
      return Connector.PROPHETPAY;
    case 67:
    case "RAPYD":
      return Connector.RAPYD;
    case 68:
    case "RAZORPAY":
      return Connector.RAZORPAY;
    case 69:
    case "RECURLY":
      return Connector.RECURLY;
    case 70:
    case "REDSYS":
      return Connector.REDSYS;
    case 71:
    case "SHIFT4":
      return Connector.SHIFT4;
    case 72:
    case "SQUARE":
      return Connector.SQUARE;
    case 73:
    case "STAX":
      return Connector.STAX;
    case 74:
    case "STRIPE":
      return Connector.STRIPE;
    case 75:
    case "TAXJAR":
      return Connector.TAXJAR;
    case 76:
    case "THREEDSECUREIO":
      return Connector.THREEDSECUREIO;
    case 77:
    case "TRUSTPAY":
      return Connector.TRUSTPAY;
    case 78:
    case "TSYS":
      return Connector.TSYS;
    case 79:
    case "VOLT":
      return Connector.VOLT;
    case 80:
    case "WELLSFARGO":
      return Connector.WELLSFARGO;
    case 81:
    case "WISE":
      return Connector.WISE;
    case 82:
    case "WORLDLINE":
      return Connector.WORLDLINE;
    case 83:
    case "WORLDPAY":
      return Connector.WORLDPAY;
    case 84:
    case "SIGNIFYD":
      return Connector.SIGNIFYD;
    case 85:
    case "PLAID":
      return Connector.PLAID;
    case 86:
    case "RISKIFIED":
      return Connector.RISKIFIED;
    case 87:
    case "XENDIT":
      return Connector.XENDIT;
    case 88:
    case "ZEN":
      return Connector.ZEN;
    case 89:
    case "ZSL":
      return Connector.ZSL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Connector.UNRECOGNIZED;
  }
}

export function connectorToJSON(object: Connector): string {
  switch (object) {
    case Connector.ADYENPLATFORM:
      return "ADYENPLATFORM";
    case Connector.ACI:
      return "ACI";
    case Connector.ADYEN:
      return "ADYEN";
    case Connector.AIRWALLEX:
      return "AIRWALLEX";
    case Connector.AUTHORIZEDOTNET:
      return "AUTHORIZEDOTNET";
    case Connector.BAMBORA:
      return "BAMBORA";
    case Connector.BAMBORAAPAC:
      return "BAMBORAAPAC";
    case Connector.BANKOFAMERICA:
      return "BANKOFAMERICA";
    case Connector.BILLWERK:
      return "BILLWERK";
    case Connector.BITPAY:
      return "BITPAY";
    case Connector.BLUESNAP:
      return "BLUESNAP";
    case Connector.BOKU:
      return "BOKU";
    case Connector.BRAINTREE:
      return "BRAINTREE";
    case Connector.CASHTOCODE:
      return "CASHTOCODE";
    case Connector.CHARGEBEE:
      return "CHARGEBEE";
    case Connector.CHECKOUT:
      return "CHECKOUT";
    case Connector.COINBASE:
      return "COINBASE";
    case Connector.COINGATE:
      return "COINGATE";
    case Connector.CRYPTOPAY:
      return "CRYPTOPAY";
    case Connector.CTP_MASTERCARD:
      return "CTP_MASTERCARD";
    case Connector.CTP_VISA:
      return "CTP_VISA";
    case Connector.CYBERSOURCE:
      return "CYBERSOURCE";
    case Connector.DATATRANS:
      return "DATATRANS";
    case Connector.DEUTSCHEBANK:
      return "DEUTSCHEBANK";
    case Connector.DIGITALVIRGO:
      return "DIGITALVIRGO";
    case Connector.DLOCAL:
      return "DLOCAL";
    case Connector.EBANX:
      return "EBANX";
    case Connector.ELAVON:
      return "ELAVON";
    case Connector.FISERV:
      return "FISERV";
    case Connector.FISERVEMEA:
      return "FISERVEMEA";
    case Connector.FIUU:
      return "FIUU";
    case Connector.FORTE:
      return "FORTE";
    case Connector.GETNET:
      return "GETNET";
    case Connector.GLOBALPAY:
      return "GLOBALPAY";
    case Connector.GLOBEPAY:
      return "GLOBEPAY";
    case Connector.GOCARDLESS:
      return "GOCARDLESS";
    case Connector.GPAYMENTS:
      return "GPAYMENTS";
    case Connector.HIPAY:
      return "HIPAY";
    case Connector.HELCIM:
      return "HELCIM";
    case Connector.INESPAY:
      return "INESPAY";
    case Connector.IATAPAY:
      return "IATAPAY";
    case Connector.ITAUBANK:
      return "ITAUBANK";
    case Connector.JPMORGAN:
      return "JPMORGAN";
    case Connector.JUSPAYTHREEDSSERVER:
      return "JUSPAYTHREEDSSERVER";
    case Connector.KLARNA:
      return "KLARNA";
    case Connector.MIFINITY:
      return "MIFINITY";
    case Connector.MOLLIE:
      return "MOLLIE";
    case Connector.MONERIS:
      return "MONERIS";
    case Connector.MULTISAFEPAY:
      return "MULTISAFEPAY";
    case Connector.NETCETERA:
      return "NETCETERA";
    case Connector.NEXINETS:
      return "NEXINETS";
    case Connector.NEXIXPAY:
      return "NEXIXPAY";
    case Connector.NMI:
      return "NMI";
    case Connector.NOMUPAY:
      return "NOMUPAY";
    case Connector.NOON:
      return "NOON";
    case Connector.NOVALNET:
      return "NOVALNET";
    case Connector.NUVEI:
      return "NUVEI";
    case Connector.OPENNODE:
      return "OPENNODE";
    case Connector.PAYBOX:
      return "PAYBOX";
    case Connector.PAYME:
      return "PAYME";
    case Connector.PAYONE:
      return "PAYONE";
    case Connector.PAYPAL:
      return "PAYPAL";
    case Connector.PAYSTACK:
      return "PAYSTACK";
    case Connector.PAYU:
      return "PAYU";
    case Connector.PLACETOPAY:
      return "PLACETOPAY";
    case Connector.POWERTRANZ:
      return "POWERTRANZ";
    case Connector.PROPHETPAY:
      return "PROPHETPAY";
    case Connector.RAPYD:
      return "RAPYD";
    case Connector.RAZORPAY:
      return "RAZORPAY";
    case Connector.RECURLY:
      return "RECURLY";
    case Connector.REDSYS:
      return "REDSYS";
    case Connector.SHIFT4:
      return "SHIFT4";
    case Connector.SQUARE:
      return "SQUARE";
    case Connector.STAX:
      return "STAX";
    case Connector.STRIPE:
      return "STRIPE";
    case Connector.TAXJAR:
      return "TAXJAR";
    case Connector.THREEDSECUREIO:
      return "THREEDSECUREIO";
    case Connector.TRUSTPAY:
      return "TRUSTPAY";
    case Connector.TSYS:
      return "TSYS";
    case Connector.VOLT:
      return "VOLT";
    case Connector.WELLSFARGO:
      return "WELLSFARGO";
    case Connector.WISE:
      return "WISE";
    case Connector.WORLDLINE:
      return "WORLDLINE";
    case Connector.WORLDPAY:
      return "WORLDPAY";
    case Connector.SIGNIFYD:
      return "SIGNIFYD";
    case Connector.PLAID:
      return "PLAID";
    case Connector.RISKIFIED:
      return "RISKIFIED";
    case Connector.XENDIT:
      return "XENDIT";
    case Connector.ZEN:
      return "ZEN";
    case Connector.ZSL:
      return "ZSL";
    case Connector.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Method {
  GET = 0,
  /** POST - Add other HTTP methods as needed */
  POST = 1,
  UNRECOGNIZED = -1,
}

export function methodFromJSON(object: any): Method {
  switch (object) {
    case 0:
    case "GET":
      return Method.GET;
    case 1:
    case "POST":
      return Method.POST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Method.UNRECOGNIZED;
  }
}

export function methodToJSON(object: Method): string {
  switch (object) {
    case Method.GET:
      return "GET";
    case Method.POST:
      return "POST";
    case Method.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Currency {
  AED = 0,
  AFN = 1,
  ALL = 2,
  AMD = 3,
  ANG = 4,
  AOA = 5,
  ARS = 6,
  AUD = 7,
  AWG = 8,
  AZN = 9,
  BAM = 10,
  BBD = 11,
  BDT = 12,
  BGN = 13,
  BHD = 14,
  BIF = 15,
  BMD = 16,
  BND = 17,
  BOB = 18,
  BRL = 19,
  BSD = 20,
  BTN = 21,
  BWP = 22,
  BYN = 23,
  BZD = 24,
  CAD = 25,
  CDF = 26,
  CHF = 27,
  CLF = 28,
  CLP = 29,
  CNY = 30,
  COP = 31,
  CRC = 32,
  CUC = 33,
  CUP = 34,
  CVE = 35,
  CZK = 36,
  DJF = 37,
  DKK = 38,
  DOP = 39,
  DZD = 40,
  EGP = 41,
  ERN = 42,
  ETB = 43,
  EUR = 44,
  FJD = 45,
  FKP = 46,
  GBP = 47,
  GEL = 48,
  GHS = 49,
  GIP = 50,
  GMD = 51,
  GNF = 52,
  GTQ = 53,
  GYD = 54,
  HKD = 55,
  HNL = 56,
  HRK = 57,
  HTG = 58,
  HUF = 59,
  IDR = 60,
  ILS = 61,
  INR = 62,
  IQD = 63,
  IRR = 64,
  ISK = 65,
  JMD = 66,
  JOD = 67,
  JPY = 68,
  KES = 69,
  KGS = 70,
  KHR = 71,
  KMF = 72,
  KPW = 73,
  KRW = 74,
  KWD = 75,
  KYD = 76,
  KZT = 77,
  LAK = 78,
  LBP = 79,
  LKR = 80,
  LRD = 81,
  LSL = 82,
  LYD = 83,
  MAD = 84,
  MDL = 85,
  MGA = 86,
  MKD = 87,
  MMK = 88,
  MNT = 89,
  MOP = 90,
  MRU = 91,
  MUR = 92,
  MVR = 93,
  MWK = 94,
  MXN = 95,
  MYR = 96,
  MZN = 97,
  NAD = 98,
  NGN = 99,
  NIO = 100,
  NOK = 101,
  NPR = 102,
  NZD = 103,
  OMR = 104,
  PAB = 105,
  PEN = 106,
  PGK = 107,
  PHP = 108,
  PKR = 109,
  PLN = 110,
  PYG = 111,
  QAR = 112,
  RON = 113,
  RSD = 114,
  RUB = 115,
  RWF = 116,
  SAR = 117,
  SBD = 118,
  SCR = 119,
  SDG = 120,
  SEK = 121,
  SGD = 122,
  SHP = 123,
  SLE = 124,
  SLL = 125,
  SOS = 126,
  SRD = 127,
  SSP = 128,
  STD = 129,
  STN = 130,
  SVC = 131,
  SYP = 132,
  SZL = 133,
  THB = 134,
  TJS = 135,
  TMT = 136,
  TND = 137,
  TOP = 138,
  TRY = 139,
  TTD = 140,
  TWD = 141,
  TZS = 142,
  UAH = 143,
  UGX = 144,
  USD = 145,
  UYU = 146,
  UZS = 147,
  VES = 148,
  VND = 149,
  VUV = 150,
  WST = 151,
  XAF = 152,
  XCD = 153,
  XOF = 154,
  XPF = 155,
  YER = 156,
  ZAR = 157,
  ZMW = 158,
  ZWL = 159,
  UNRECOGNIZED = -1,
}

export function currencyFromJSON(object: any): Currency {
  switch (object) {
    case 0:
    case "AED":
      return Currency.AED;
    case 1:
    case "AFN":
      return Currency.AFN;
    case 2:
    case "ALL":
      return Currency.ALL;
    case 3:
    case "AMD":
      return Currency.AMD;
    case 4:
    case "ANG":
      return Currency.ANG;
    case 5:
    case "AOA":
      return Currency.AOA;
    case 6:
    case "ARS":
      return Currency.ARS;
    case 7:
    case "AUD":
      return Currency.AUD;
    case 8:
    case "AWG":
      return Currency.AWG;
    case 9:
    case "AZN":
      return Currency.AZN;
    case 10:
    case "BAM":
      return Currency.BAM;
    case 11:
    case "BBD":
      return Currency.BBD;
    case 12:
    case "BDT":
      return Currency.BDT;
    case 13:
    case "BGN":
      return Currency.BGN;
    case 14:
    case "BHD":
      return Currency.BHD;
    case 15:
    case "BIF":
      return Currency.BIF;
    case 16:
    case "BMD":
      return Currency.BMD;
    case 17:
    case "BND":
      return Currency.BND;
    case 18:
    case "BOB":
      return Currency.BOB;
    case 19:
    case "BRL":
      return Currency.BRL;
    case 20:
    case "BSD":
      return Currency.BSD;
    case 21:
    case "BTN":
      return Currency.BTN;
    case 22:
    case "BWP":
      return Currency.BWP;
    case 23:
    case "BYN":
      return Currency.BYN;
    case 24:
    case "BZD":
      return Currency.BZD;
    case 25:
    case "CAD":
      return Currency.CAD;
    case 26:
    case "CDF":
      return Currency.CDF;
    case 27:
    case "CHF":
      return Currency.CHF;
    case 28:
    case "CLF":
      return Currency.CLF;
    case 29:
    case "CLP":
      return Currency.CLP;
    case 30:
    case "CNY":
      return Currency.CNY;
    case 31:
    case "COP":
      return Currency.COP;
    case 32:
    case "CRC":
      return Currency.CRC;
    case 33:
    case "CUC":
      return Currency.CUC;
    case 34:
    case "CUP":
      return Currency.CUP;
    case 35:
    case "CVE":
      return Currency.CVE;
    case 36:
    case "CZK":
      return Currency.CZK;
    case 37:
    case "DJF":
      return Currency.DJF;
    case 38:
    case "DKK":
      return Currency.DKK;
    case 39:
    case "DOP":
      return Currency.DOP;
    case 40:
    case "DZD":
      return Currency.DZD;
    case 41:
    case "EGP":
      return Currency.EGP;
    case 42:
    case "ERN":
      return Currency.ERN;
    case 43:
    case "ETB":
      return Currency.ETB;
    case 44:
    case "EUR":
      return Currency.EUR;
    case 45:
    case "FJD":
      return Currency.FJD;
    case 46:
    case "FKP":
      return Currency.FKP;
    case 47:
    case "GBP":
      return Currency.GBP;
    case 48:
    case "GEL":
      return Currency.GEL;
    case 49:
    case "GHS":
      return Currency.GHS;
    case 50:
    case "GIP":
      return Currency.GIP;
    case 51:
    case "GMD":
      return Currency.GMD;
    case 52:
    case "GNF":
      return Currency.GNF;
    case 53:
    case "GTQ":
      return Currency.GTQ;
    case 54:
    case "GYD":
      return Currency.GYD;
    case 55:
    case "HKD":
      return Currency.HKD;
    case 56:
    case "HNL":
      return Currency.HNL;
    case 57:
    case "HRK":
      return Currency.HRK;
    case 58:
    case "HTG":
      return Currency.HTG;
    case 59:
    case "HUF":
      return Currency.HUF;
    case 60:
    case "IDR":
      return Currency.IDR;
    case 61:
    case "ILS":
      return Currency.ILS;
    case 62:
    case "INR":
      return Currency.INR;
    case 63:
    case "IQD":
      return Currency.IQD;
    case 64:
    case "IRR":
      return Currency.IRR;
    case 65:
    case "ISK":
      return Currency.ISK;
    case 66:
    case "JMD":
      return Currency.JMD;
    case 67:
    case "JOD":
      return Currency.JOD;
    case 68:
    case "JPY":
      return Currency.JPY;
    case 69:
    case "KES":
      return Currency.KES;
    case 70:
    case "KGS":
      return Currency.KGS;
    case 71:
    case "KHR":
      return Currency.KHR;
    case 72:
    case "KMF":
      return Currency.KMF;
    case 73:
    case "KPW":
      return Currency.KPW;
    case 74:
    case "KRW":
      return Currency.KRW;
    case 75:
    case "KWD":
      return Currency.KWD;
    case 76:
    case "KYD":
      return Currency.KYD;
    case 77:
    case "KZT":
      return Currency.KZT;
    case 78:
    case "LAK":
      return Currency.LAK;
    case 79:
    case "LBP":
      return Currency.LBP;
    case 80:
    case "LKR":
      return Currency.LKR;
    case 81:
    case "LRD":
      return Currency.LRD;
    case 82:
    case "LSL":
      return Currency.LSL;
    case 83:
    case "LYD":
      return Currency.LYD;
    case 84:
    case "MAD":
      return Currency.MAD;
    case 85:
    case "MDL":
      return Currency.MDL;
    case 86:
    case "MGA":
      return Currency.MGA;
    case 87:
    case "MKD":
      return Currency.MKD;
    case 88:
    case "MMK":
      return Currency.MMK;
    case 89:
    case "MNT":
      return Currency.MNT;
    case 90:
    case "MOP":
      return Currency.MOP;
    case 91:
    case "MRU":
      return Currency.MRU;
    case 92:
    case "MUR":
      return Currency.MUR;
    case 93:
    case "MVR":
      return Currency.MVR;
    case 94:
    case "MWK":
      return Currency.MWK;
    case 95:
    case "MXN":
      return Currency.MXN;
    case 96:
    case "MYR":
      return Currency.MYR;
    case 97:
    case "MZN":
      return Currency.MZN;
    case 98:
    case "NAD":
      return Currency.NAD;
    case 99:
    case "NGN":
      return Currency.NGN;
    case 100:
    case "NIO":
      return Currency.NIO;
    case 101:
    case "NOK":
      return Currency.NOK;
    case 102:
    case "NPR":
      return Currency.NPR;
    case 103:
    case "NZD":
      return Currency.NZD;
    case 104:
    case "OMR":
      return Currency.OMR;
    case 105:
    case "PAB":
      return Currency.PAB;
    case 106:
    case "PEN":
      return Currency.PEN;
    case 107:
    case "PGK":
      return Currency.PGK;
    case 108:
    case "PHP":
      return Currency.PHP;
    case 109:
    case "PKR":
      return Currency.PKR;
    case 110:
    case "PLN":
      return Currency.PLN;
    case 111:
    case "PYG":
      return Currency.PYG;
    case 112:
    case "QAR":
      return Currency.QAR;
    case 113:
    case "RON":
      return Currency.RON;
    case 114:
    case "RSD":
      return Currency.RSD;
    case 115:
    case "RUB":
      return Currency.RUB;
    case 116:
    case "RWF":
      return Currency.RWF;
    case 117:
    case "SAR":
      return Currency.SAR;
    case 118:
    case "SBD":
      return Currency.SBD;
    case 119:
    case "SCR":
      return Currency.SCR;
    case 120:
    case "SDG":
      return Currency.SDG;
    case 121:
    case "SEK":
      return Currency.SEK;
    case 122:
    case "SGD":
      return Currency.SGD;
    case 123:
    case "SHP":
      return Currency.SHP;
    case 124:
    case "SLE":
      return Currency.SLE;
    case 125:
    case "SLL":
      return Currency.SLL;
    case 126:
    case "SOS":
      return Currency.SOS;
    case 127:
    case "SRD":
      return Currency.SRD;
    case 128:
    case "SSP":
      return Currency.SSP;
    case 129:
    case "STD":
      return Currency.STD;
    case 130:
    case "STN":
      return Currency.STN;
    case 131:
    case "SVC":
      return Currency.SVC;
    case 132:
    case "SYP":
      return Currency.SYP;
    case 133:
    case "SZL":
      return Currency.SZL;
    case 134:
    case "THB":
      return Currency.THB;
    case 135:
    case "TJS":
      return Currency.TJS;
    case 136:
    case "TMT":
      return Currency.TMT;
    case 137:
    case "TND":
      return Currency.TND;
    case 138:
    case "TOP":
      return Currency.TOP;
    case 139:
    case "TRY":
      return Currency.TRY;
    case 140:
    case "TTD":
      return Currency.TTD;
    case 141:
    case "TWD":
      return Currency.TWD;
    case 142:
    case "TZS":
      return Currency.TZS;
    case 143:
    case "UAH":
      return Currency.UAH;
    case 144:
    case "UGX":
      return Currency.UGX;
    case 145:
    case "USD":
      return Currency.USD;
    case 146:
    case "UYU":
      return Currency.UYU;
    case 147:
    case "UZS":
      return Currency.UZS;
    case 148:
    case "VES":
      return Currency.VES;
    case 149:
    case "VND":
      return Currency.VND;
    case 150:
    case "VUV":
      return Currency.VUV;
    case 151:
    case "WST":
      return Currency.WST;
    case 152:
    case "XAF":
      return Currency.XAF;
    case 153:
    case "XCD":
      return Currency.XCD;
    case 154:
    case "XOF":
      return Currency.XOF;
    case 155:
    case "XPF":
      return Currency.XPF;
    case 156:
    case "YER":
      return Currency.YER;
    case 157:
    case "ZAR":
      return Currency.ZAR;
    case 158:
    case "ZMW":
      return Currency.ZMW;
    case 159:
    case "ZWL":
      return Currency.ZWL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Currency.UNRECOGNIZED;
  }
}

export function currencyToJSON(object: Currency): string {
  switch (object) {
    case Currency.AED:
      return "AED";
    case Currency.AFN:
      return "AFN";
    case Currency.ALL:
      return "ALL";
    case Currency.AMD:
      return "AMD";
    case Currency.ANG:
      return "ANG";
    case Currency.AOA:
      return "AOA";
    case Currency.ARS:
      return "ARS";
    case Currency.AUD:
      return "AUD";
    case Currency.AWG:
      return "AWG";
    case Currency.AZN:
      return "AZN";
    case Currency.BAM:
      return "BAM";
    case Currency.BBD:
      return "BBD";
    case Currency.BDT:
      return "BDT";
    case Currency.BGN:
      return "BGN";
    case Currency.BHD:
      return "BHD";
    case Currency.BIF:
      return "BIF";
    case Currency.BMD:
      return "BMD";
    case Currency.BND:
      return "BND";
    case Currency.BOB:
      return "BOB";
    case Currency.BRL:
      return "BRL";
    case Currency.BSD:
      return "BSD";
    case Currency.BTN:
      return "BTN";
    case Currency.BWP:
      return "BWP";
    case Currency.BYN:
      return "BYN";
    case Currency.BZD:
      return "BZD";
    case Currency.CAD:
      return "CAD";
    case Currency.CDF:
      return "CDF";
    case Currency.CHF:
      return "CHF";
    case Currency.CLF:
      return "CLF";
    case Currency.CLP:
      return "CLP";
    case Currency.CNY:
      return "CNY";
    case Currency.COP:
      return "COP";
    case Currency.CRC:
      return "CRC";
    case Currency.CUC:
      return "CUC";
    case Currency.CUP:
      return "CUP";
    case Currency.CVE:
      return "CVE";
    case Currency.CZK:
      return "CZK";
    case Currency.DJF:
      return "DJF";
    case Currency.DKK:
      return "DKK";
    case Currency.DOP:
      return "DOP";
    case Currency.DZD:
      return "DZD";
    case Currency.EGP:
      return "EGP";
    case Currency.ERN:
      return "ERN";
    case Currency.ETB:
      return "ETB";
    case Currency.EUR:
      return "EUR";
    case Currency.FJD:
      return "FJD";
    case Currency.FKP:
      return "FKP";
    case Currency.GBP:
      return "GBP";
    case Currency.GEL:
      return "GEL";
    case Currency.GHS:
      return "GHS";
    case Currency.GIP:
      return "GIP";
    case Currency.GMD:
      return "GMD";
    case Currency.GNF:
      return "GNF";
    case Currency.GTQ:
      return "GTQ";
    case Currency.GYD:
      return "GYD";
    case Currency.HKD:
      return "HKD";
    case Currency.HNL:
      return "HNL";
    case Currency.HRK:
      return "HRK";
    case Currency.HTG:
      return "HTG";
    case Currency.HUF:
      return "HUF";
    case Currency.IDR:
      return "IDR";
    case Currency.ILS:
      return "ILS";
    case Currency.INR:
      return "INR";
    case Currency.IQD:
      return "IQD";
    case Currency.IRR:
      return "IRR";
    case Currency.ISK:
      return "ISK";
    case Currency.JMD:
      return "JMD";
    case Currency.JOD:
      return "JOD";
    case Currency.JPY:
      return "JPY";
    case Currency.KES:
      return "KES";
    case Currency.KGS:
      return "KGS";
    case Currency.KHR:
      return "KHR";
    case Currency.KMF:
      return "KMF";
    case Currency.KPW:
      return "KPW";
    case Currency.KRW:
      return "KRW";
    case Currency.KWD:
      return "KWD";
    case Currency.KYD:
      return "KYD";
    case Currency.KZT:
      return "KZT";
    case Currency.LAK:
      return "LAK";
    case Currency.LBP:
      return "LBP";
    case Currency.LKR:
      return "LKR";
    case Currency.LRD:
      return "LRD";
    case Currency.LSL:
      return "LSL";
    case Currency.LYD:
      return "LYD";
    case Currency.MAD:
      return "MAD";
    case Currency.MDL:
      return "MDL";
    case Currency.MGA:
      return "MGA";
    case Currency.MKD:
      return "MKD";
    case Currency.MMK:
      return "MMK";
    case Currency.MNT:
      return "MNT";
    case Currency.MOP:
      return "MOP";
    case Currency.MRU:
      return "MRU";
    case Currency.MUR:
      return "MUR";
    case Currency.MVR:
      return "MVR";
    case Currency.MWK:
      return "MWK";
    case Currency.MXN:
      return "MXN";
    case Currency.MYR:
      return "MYR";
    case Currency.MZN:
      return "MZN";
    case Currency.NAD:
      return "NAD";
    case Currency.NGN:
      return "NGN";
    case Currency.NIO:
      return "NIO";
    case Currency.NOK:
      return "NOK";
    case Currency.NPR:
      return "NPR";
    case Currency.NZD:
      return "NZD";
    case Currency.OMR:
      return "OMR";
    case Currency.PAB:
      return "PAB";
    case Currency.PEN:
      return "PEN";
    case Currency.PGK:
      return "PGK";
    case Currency.PHP:
      return "PHP";
    case Currency.PKR:
      return "PKR";
    case Currency.PLN:
      return "PLN";
    case Currency.PYG:
      return "PYG";
    case Currency.QAR:
      return "QAR";
    case Currency.RON:
      return "RON";
    case Currency.RSD:
      return "RSD";
    case Currency.RUB:
      return "RUB";
    case Currency.RWF:
      return "RWF";
    case Currency.SAR:
      return "SAR";
    case Currency.SBD:
      return "SBD";
    case Currency.SCR:
      return "SCR";
    case Currency.SDG:
      return "SDG";
    case Currency.SEK:
      return "SEK";
    case Currency.SGD:
      return "SGD";
    case Currency.SHP:
      return "SHP";
    case Currency.SLE:
      return "SLE";
    case Currency.SLL:
      return "SLL";
    case Currency.SOS:
      return "SOS";
    case Currency.SRD:
      return "SRD";
    case Currency.SSP:
      return "SSP";
    case Currency.STD:
      return "STD";
    case Currency.STN:
      return "STN";
    case Currency.SVC:
      return "SVC";
    case Currency.SYP:
      return "SYP";
    case Currency.SZL:
      return "SZL";
    case Currency.THB:
      return "THB";
    case Currency.TJS:
      return "TJS";
    case Currency.TMT:
      return "TMT";
    case Currency.TND:
      return "TND";
    case Currency.TOP:
      return "TOP";
    case Currency.TRY:
      return "TRY";
    case Currency.TTD:
      return "TTD";
    case Currency.TWD:
      return "TWD";
    case Currency.TZS:
      return "TZS";
    case Currency.UAH:
      return "UAH";
    case Currency.UGX:
      return "UGX";
    case Currency.USD:
      return "USD";
    case Currency.UYU:
      return "UYU";
    case Currency.UZS:
      return "UZS";
    case Currency.VES:
      return "VES";
    case Currency.VND:
      return "VND";
    case Currency.VUV:
      return "VUV";
    case Currency.WST:
      return "WST";
    case Currency.XAF:
      return "XAF";
    case Currency.XCD:
      return "XCD";
    case Currency.XOF:
      return "XOF";
    case Currency.XPF:
      return "XPF";
    case Currency.YER:
      return "YER";
    case Currency.ZAR:
      return "ZAR";
    case Currency.ZMW:
      return "ZMW";
    case Currency.ZWL:
      return "ZWL";
    case Currency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CaptureMethod {
  AUTOMATIC = 0,
  MANUAL = 1,
  MANUAL_MULTIPLE = 2,
  SCHEDULED = 3,
  SEQUENTIAL_AUTOMATIC = 4,
  UNRECOGNIZED = -1,
}

export function captureMethodFromJSON(object: any): CaptureMethod {
  switch (object) {
    case 0:
    case "AUTOMATIC":
      return CaptureMethod.AUTOMATIC;
    case 1:
    case "MANUAL":
      return CaptureMethod.MANUAL;
    case 2:
    case "MANUAL_MULTIPLE":
      return CaptureMethod.MANUAL_MULTIPLE;
    case 3:
    case "SCHEDULED":
      return CaptureMethod.SCHEDULED;
    case 4:
    case "SEQUENTIAL_AUTOMATIC":
      return CaptureMethod.SEQUENTIAL_AUTOMATIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaptureMethod.UNRECOGNIZED;
  }
}

export function captureMethodToJSON(object: CaptureMethod): string {
  switch (object) {
    case CaptureMethod.AUTOMATIC:
      return "AUTOMATIC";
    case CaptureMethod.MANUAL:
      return "MANUAL";
    case CaptureMethod.MANUAL_MULTIPLE:
      return "MANUAL_MULTIPLE";
    case CaptureMethod.SCHEDULED:
      return "SCHEDULED";
    case CaptureMethod.SEQUENTIAL_AUTOMATIC:
      return "SEQUENTIAL_AUTOMATIC";
    case CaptureMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FutureUsage {
  OFF_SESSION = 0,
  ON_SESSION = 1,
  UNRECOGNIZED = -1,
}

export function futureUsageFromJSON(object: any): FutureUsage {
  switch (object) {
    case 0:
    case "OFF_SESSION":
      return FutureUsage.OFF_SESSION;
    case 1:
    case "ON_SESSION":
      return FutureUsage.ON_SESSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FutureUsage.UNRECOGNIZED;
  }
}

export function futureUsageToJSON(object: FutureUsage): string {
  switch (object) {
    case FutureUsage.OFF_SESSION:
      return "OFF_SESSION";
    case FutureUsage.ON_SESSION:
      return "ON_SESSION";
    case FutureUsage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AcceptanceType {
  ONLINE = 0,
  OFFLINE = 1,
  UNRECOGNIZED = -1,
}

export function acceptanceTypeFromJSON(object: any): AcceptanceType {
  switch (object) {
    case 0:
    case "ONLINE":
      return AcceptanceType.ONLINE;
    case 1:
    case "OFFLINE":
      return AcceptanceType.OFFLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceptanceType.UNRECOGNIZED;
  }
}

export function acceptanceTypeToJSON(object: AcceptanceType): string {
  switch (object) {
    case AcceptanceType.ONLINE:
      return "ONLINE";
    case AcceptanceType.OFFLINE:
      return "OFFLINE";
    case AcceptanceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentExperience {
  REDIRECT_TO_URL = 0,
  INVOKE_SDK_CLIENT = 1,
  DISPLAY_QR_CODE = 2,
  ONE_CLICK = 3,
  LINK_WALLET = 4,
  INVOKE_PAYMENT_APP = 5,
  DISPLAY_WAIT_SCREEN = 6,
  COLLECT_OTP = 7,
  UNRECOGNIZED = -1,
}

export function paymentExperienceFromJSON(object: any): PaymentExperience {
  switch (object) {
    case 0:
    case "REDIRECT_TO_URL":
      return PaymentExperience.REDIRECT_TO_URL;
    case 1:
    case "INVOKE_SDK_CLIENT":
      return PaymentExperience.INVOKE_SDK_CLIENT;
    case 2:
    case "DISPLAY_QR_CODE":
      return PaymentExperience.DISPLAY_QR_CODE;
    case 3:
    case "ONE_CLICK":
      return PaymentExperience.ONE_CLICK;
    case 4:
    case "LINK_WALLET":
      return PaymentExperience.LINK_WALLET;
    case 5:
    case "INVOKE_PAYMENT_APP":
      return PaymentExperience.INVOKE_PAYMENT_APP;
    case 6:
    case "DISPLAY_WAIT_SCREEN":
      return PaymentExperience.DISPLAY_WAIT_SCREEN;
    case 7:
    case "COLLECT_OTP":
      return PaymentExperience.COLLECT_OTP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentExperience.UNRECOGNIZED;
  }
}

export function paymentExperienceToJSON(object: PaymentExperience): string {
  switch (object) {
    case PaymentExperience.REDIRECT_TO_URL:
      return "REDIRECT_TO_URL";
    case PaymentExperience.INVOKE_SDK_CLIENT:
      return "INVOKE_SDK_CLIENT";
    case PaymentExperience.DISPLAY_QR_CODE:
      return "DISPLAY_QR_CODE";
    case PaymentExperience.ONE_CLICK:
      return "ONE_CLICK";
    case PaymentExperience.LINK_WALLET:
      return "LINK_WALLET";
    case PaymentExperience.INVOKE_PAYMENT_APP:
      return "INVOKE_PAYMENT_APP";
    case PaymentExperience.DISPLAY_WAIT_SCREEN:
      return "DISPLAY_WAIT_SCREEN";
    case PaymentExperience.COLLECT_OTP:
      return "COLLECT_OTP";
    case PaymentExperience.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentMethodType {
  ACH = 0,
  AFFIRM = 1,
  AFTERPAY_CLEARPAY = 2,
  ALFAMART = 3,
  ALI_PAY = 4,
  ALI_PAY_HK = 5,
  ALMA = 6,
  AMAZON_PAY = 7,
  APPLE_PAY = 8,
  ATOME = 9,
  BACS = 10,
  BANCONTACT_CARD = 11,
  BECS = 12,
  BENEFIT = 13,
  BIZUM = 14,
  BLIK = 15,
  BOLETO = 16,
  BCA_BANK_TRANSFER = 17,
  BNI_VA = 18,
  BRI_VA = 19,
  CARD_REDIRECT = 20,
  CIMB_VA = 21,
  CLASSIC_REWARD = 22,
  CREDIT = 23,
  CRYPTO_CURRENCY = 24,
  CASHAPP = 25,
  DANA = 26,
  DANAMON_VA = 27,
  DEBIT = 28,
  DUIT_NOW = 29,
  EFECTY = 30,
  EFT = 31,
  EPS = 32,
  FPS = 33,
  EVOUCHER = 34,
  GIROPAY = 35,
  GIVEX = 36,
  GOOGLE_PAY = 37,
  GO_PAY = 38,
  GCASH = 39,
  IDEAL = 40,
  INTERAC = 41,
  INDOMARET = 42,
  KAKAO_PAY = 44,
  LOCAL_BANK_REDIRECT = 45,
  MANDIRI_VA = 46,
  KNET = 47,
  MB_WAY = 48,
  MOBILE_PAY = 49,
  MOMO = 50,
  MOMO_ATM = 51,
  MULTIBANCO = 52,
  ONLINE_BANKING_THAILAND = 53,
  ONLINE_BANKING_CZECH_REPUBLIC = 54,
  ONLINE_BANKING_FINLAND = 55,
  ONLINE_BANKING_FPX = 56,
  ONLINE_BANKING_POLAND = 57,
  ONLINE_BANKING_SLOVAKIA = 58,
  OXXO = 59,
  PAGO_EFECTIVO = 60,
  PERMATA_BANK_TRANSFER = 61,
  OPEN_BANKING_UK = 62,
  PAY_BRIGHT = 63,
  PAZE = 65,
  PIX = 66,
  PAY_SAFE_CARD = 67,
  PRZELEWY24 = 68,
  PROMPT_PAY = 69,
  PSE = 70,
  RED_COMPRA = 71,
  RED_PAGOS = 72,
  SAMSUNG_PAY = 73,
  SEPA = 74,
  SEPA_BANK_TRANSFER = 75,
  SOFORT = 76,
  SWISH = 77,
  TOUCH_N_GO = 78,
  TRUSTLY = 79,
  TWINT = 80,
  UPI_COLLECT = 81,
  UPI_INTENT = 82,
  VIPPS = 83,
  VIET_QR = 84,
  VENMO = 85,
  WALLEY = 86,
  WE_CHAT_PAY = 87,
  SEVEN_ELEVEN = 88,
  LAWSON = 89,
  MINI_STOP = 90,
  FAMILY_MART = 91,
  SEICOMART = 92,
  PAY_EASY = 93,
  LOCAL_BANK_TRANSFER = 94,
  OPEN_BANKING_PIS = 96,
  DIRECT_CARRIER_BILLING = 97,
  INSTANT_BANK_TRANSFER = 98,
  UNRECOGNIZED = -1,
}

export function paymentMethodTypeFromJSON(object: any): PaymentMethodType {
  switch (object) {
    case 0:
    case "ACH":
      return PaymentMethodType.ACH;
    case 1:
    case "AFFIRM":
      return PaymentMethodType.AFFIRM;
    case 2:
    case "AFTERPAY_CLEARPAY":
      return PaymentMethodType.AFTERPAY_CLEARPAY;
    case 3:
    case "ALFAMART":
      return PaymentMethodType.ALFAMART;
    case 4:
    case "ALI_PAY":
      return PaymentMethodType.ALI_PAY;
    case 5:
    case "ALI_PAY_HK":
      return PaymentMethodType.ALI_PAY_HK;
    case 6:
    case "ALMA":
      return PaymentMethodType.ALMA;
    case 7:
    case "AMAZON_PAY":
      return PaymentMethodType.AMAZON_PAY;
    case 8:
    case "APPLE_PAY":
      return PaymentMethodType.APPLE_PAY;
    case 9:
    case "ATOME":
      return PaymentMethodType.ATOME;
    case 10:
    case "BACS":
      return PaymentMethodType.BACS;
    case 11:
    case "BANCONTACT_CARD":
      return PaymentMethodType.BANCONTACT_CARD;
    case 12:
    case "BECS":
      return PaymentMethodType.BECS;
    case 13:
    case "BENEFIT":
      return PaymentMethodType.BENEFIT;
    case 14:
    case "BIZUM":
      return PaymentMethodType.BIZUM;
    case 15:
    case "BLIK":
      return PaymentMethodType.BLIK;
    case 16:
    case "BOLETO":
      return PaymentMethodType.BOLETO;
    case 17:
    case "BCA_BANK_TRANSFER":
      return PaymentMethodType.BCA_BANK_TRANSFER;
    case 18:
    case "BNI_VA":
      return PaymentMethodType.BNI_VA;
    case 19:
    case "BRI_VA":
      return PaymentMethodType.BRI_VA;
    case 20:
    case "CARD_REDIRECT":
      return PaymentMethodType.CARD_REDIRECT;
    case 21:
    case "CIMB_VA":
      return PaymentMethodType.CIMB_VA;
    case 22:
    case "CLASSIC_REWARD":
      return PaymentMethodType.CLASSIC_REWARD;
    case 23:
    case "CREDIT":
      return PaymentMethodType.CREDIT;
    case 24:
    case "CRYPTO_CURRENCY":
      return PaymentMethodType.CRYPTO_CURRENCY;
    case 25:
    case "CASHAPP":
      return PaymentMethodType.CASHAPP;
    case 26:
    case "DANA":
      return PaymentMethodType.DANA;
    case 27:
    case "DANAMON_VA":
      return PaymentMethodType.DANAMON_VA;
    case 28:
    case "DEBIT":
      return PaymentMethodType.DEBIT;
    case 29:
    case "DUIT_NOW":
      return PaymentMethodType.DUIT_NOW;
    case 30:
    case "EFECTY":
      return PaymentMethodType.EFECTY;
    case 31:
    case "EFT":
      return PaymentMethodType.EFT;
    case 32:
    case "EPS":
      return PaymentMethodType.EPS;
    case 33:
    case "FPS":
      return PaymentMethodType.FPS;
    case 34:
    case "EVOUCHER":
      return PaymentMethodType.EVOUCHER;
    case 35:
    case "GIROPAY":
      return PaymentMethodType.GIROPAY;
    case 36:
    case "GIVEX":
      return PaymentMethodType.GIVEX;
    case 37:
    case "GOOGLE_PAY":
      return PaymentMethodType.GOOGLE_PAY;
    case 38:
    case "GO_PAY":
      return PaymentMethodType.GO_PAY;
    case 39:
    case "GCASH":
      return PaymentMethodType.GCASH;
    case 40:
    case "IDEAL":
      return PaymentMethodType.IDEAL;
    case 41:
    case "INTERAC":
      return PaymentMethodType.INTERAC;
    case 42:
    case "INDOMARET":
      return PaymentMethodType.INDOMARET;
    case 44:
    case "KAKAO_PAY":
      return PaymentMethodType.KAKAO_PAY;
    case 45:
    case "LOCAL_BANK_REDIRECT":
      return PaymentMethodType.LOCAL_BANK_REDIRECT;
    case 46:
    case "MANDIRI_VA":
      return PaymentMethodType.MANDIRI_VA;
    case 47:
    case "KNET":
      return PaymentMethodType.KNET;
    case 48:
    case "MB_WAY":
      return PaymentMethodType.MB_WAY;
    case 49:
    case "MOBILE_PAY":
      return PaymentMethodType.MOBILE_PAY;
    case 50:
    case "MOMO":
      return PaymentMethodType.MOMO;
    case 51:
    case "MOMO_ATM":
      return PaymentMethodType.MOMO_ATM;
    case 52:
    case "MULTIBANCO":
      return PaymentMethodType.MULTIBANCO;
    case 53:
    case "ONLINE_BANKING_THAILAND":
      return PaymentMethodType.ONLINE_BANKING_THAILAND;
    case 54:
    case "ONLINE_BANKING_CZECH_REPUBLIC":
      return PaymentMethodType.ONLINE_BANKING_CZECH_REPUBLIC;
    case 55:
    case "ONLINE_BANKING_FINLAND":
      return PaymentMethodType.ONLINE_BANKING_FINLAND;
    case 56:
    case "ONLINE_BANKING_FPX":
      return PaymentMethodType.ONLINE_BANKING_FPX;
    case 57:
    case "ONLINE_BANKING_POLAND":
      return PaymentMethodType.ONLINE_BANKING_POLAND;
    case 58:
    case "ONLINE_BANKING_SLOVAKIA":
      return PaymentMethodType.ONLINE_BANKING_SLOVAKIA;
    case 59:
    case "OXXO":
      return PaymentMethodType.OXXO;
    case 60:
    case "PAGO_EFECTIVO":
      return PaymentMethodType.PAGO_EFECTIVO;
    case 61:
    case "PERMATA_BANK_TRANSFER":
      return PaymentMethodType.PERMATA_BANK_TRANSFER;
    case 62:
    case "OPEN_BANKING_UK":
      return PaymentMethodType.OPEN_BANKING_UK;
    case 63:
    case "PAY_BRIGHT":
      return PaymentMethodType.PAY_BRIGHT;
    case 65:
    case "PAZE":
      return PaymentMethodType.PAZE;
    case 66:
    case "PIX":
      return PaymentMethodType.PIX;
    case 67:
    case "PAY_SAFE_CARD":
      return PaymentMethodType.PAY_SAFE_CARD;
    case 68:
    case "PRZELEWY24":
      return PaymentMethodType.PRZELEWY24;
    case 69:
    case "PROMPT_PAY":
      return PaymentMethodType.PROMPT_PAY;
    case 70:
    case "PSE":
      return PaymentMethodType.PSE;
    case 71:
    case "RED_COMPRA":
      return PaymentMethodType.RED_COMPRA;
    case 72:
    case "RED_PAGOS":
      return PaymentMethodType.RED_PAGOS;
    case 73:
    case "SAMSUNG_PAY":
      return PaymentMethodType.SAMSUNG_PAY;
    case 74:
    case "SEPA":
      return PaymentMethodType.SEPA;
    case 75:
    case "SEPA_BANK_TRANSFER":
      return PaymentMethodType.SEPA_BANK_TRANSFER;
    case 76:
    case "SOFORT":
      return PaymentMethodType.SOFORT;
    case 77:
    case "SWISH":
      return PaymentMethodType.SWISH;
    case 78:
    case "TOUCH_N_GO":
      return PaymentMethodType.TOUCH_N_GO;
    case 79:
    case "TRUSTLY":
      return PaymentMethodType.TRUSTLY;
    case 80:
    case "TWINT":
      return PaymentMethodType.TWINT;
    case 81:
    case "UPI_COLLECT":
      return PaymentMethodType.UPI_COLLECT;
    case 82:
    case "UPI_INTENT":
      return PaymentMethodType.UPI_INTENT;
    case 83:
    case "VIPPS":
      return PaymentMethodType.VIPPS;
    case 84:
    case "VIET_QR":
      return PaymentMethodType.VIET_QR;
    case 85:
    case "VENMO":
      return PaymentMethodType.VENMO;
    case 86:
    case "WALLEY":
      return PaymentMethodType.WALLEY;
    case 87:
    case "WE_CHAT_PAY":
      return PaymentMethodType.WE_CHAT_PAY;
    case 88:
    case "SEVEN_ELEVEN":
      return PaymentMethodType.SEVEN_ELEVEN;
    case 89:
    case "LAWSON":
      return PaymentMethodType.LAWSON;
    case 90:
    case "MINI_STOP":
      return PaymentMethodType.MINI_STOP;
    case 91:
    case "FAMILY_MART":
      return PaymentMethodType.FAMILY_MART;
    case 92:
    case "SEICOMART":
      return PaymentMethodType.SEICOMART;
    case 93:
    case "PAY_EASY":
      return PaymentMethodType.PAY_EASY;
    case 94:
    case "LOCAL_BANK_TRANSFER":
      return PaymentMethodType.LOCAL_BANK_TRANSFER;
    case 96:
    case "OPEN_BANKING_PIS":
      return PaymentMethodType.OPEN_BANKING_PIS;
    case 97:
    case "DIRECT_CARRIER_BILLING":
      return PaymentMethodType.DIRECT_CARRIER_BILLING;
    case 98:
    case "INSTANT_BANK_TRANSFER":
      return PaymentMethodType.INSTANT_BANK_TRANSFER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentMethodType.UNRECOGNIZED;
  }
}

export function paymentMethodTypeToJSON(object: PaymentMethodType): string {
  switch (object) {
    case PaymentMethodType.ACH:
      return "ACH";
    case PaymentMethodType.AFFIRM:
      return "AFFIRM";
    case PaymentMethodType.AFTERPAY_CLEARPAY:
      return "AFTERPAY_CLEARPAY";
    case PaymentMethodType.ALFAMART:
      return "ALFAMART";
    case PaymentMethodType.ALI_PAY:
      return "ALI_PAY";
    case PaymentMethodType.ALI_PAY_HK:
      return "ALI_PAY_HK";
    case PaymentMethodType.ALMA:
      return "ALMA";
    case PaymentMethodType.AMAZON_PAY:
      return "AMAZON_PAY";
    case PaymentMethodType.APPLE_PAY:
      return "APPLE_PAY";
    case PaymentMethodType.ATOME:
      return "ATOME";
    case PaymentMethodType.BACS:
      return "BACS";
    case PaymentMethodType.BANCONTACT_CARD:
      return "BANCONTACT_CARD";
    case PaymentMethodType.BECS:
      return "BECS";
    case PaymentMethodType.BENEFIT:
      return "BENEFIT";
    case PaymentMethodType.BIZUM:
      return "BIZUM";
    case PaymentMethodType.BLIK:
      return "BLIK";
    case PaymentMethodType.BOLETO:
      return "BOLETO";
    case PaymentMethodType.BCA_BANK_TRANSFER:
      return "BCA_BANK_TRANSFER";
    case PaymentMethodType.BNI_VA:
      return "BNI_VA";
    case PaymentMethodType.BRI_VA:
      return "BRI_VA";
    case PaymentMethodType.CARD_REDIRECT:
      return "CARD_REDIRECT";
    case PaymentMethodType.CIMB_VA:
      return "CIMB_VA";
    case PaymentMethodType.CLASSIC_REWARD:
      return "CLASSIC_REWARD";
    case PaymentMethodType.CREDIT:
      return "CREDIT";
    case PaymentMethodType.CRYPTO_CURRENCY:
      return "CRYPTO_CURRENCY";
    case PaymentMethodType.CASHAPP:
      return "CASHAPP";
    case PaymentMethodType.DANA:
      return "DANA";
    case PaymentMethodType.DANAMON_VA:
      return "DANAMON_VA";
    case PaymentMethodType.DEBIT:
      return "DEBIT";
    case PaymentMethodType.DUIT_NOW:
      return "DUIT_NOW";
    case PaymentMethodType.EFECTY:
      return "EFECTY";
    case PaymentMethodType.EFT:
      return "EFT";
    case PaymentMethodType.EPS:
      return "EPS";
    case PaymentMethodType.FPS:
      return "FPS";
    case PaymentMethodType.EVOUCHER:
      return "EVOUCHER";
    case PaymentMethodType.GIROPAY:
      return "GIROPAY";
    case PaymentMethodType.GIVEX:
      return "GIVEX";
    case PaymentMethodType.GOOGLE_PAY:
      return "GOOGLE_PAY";
    case PaymentMethodType.GO_PAY:
      return "GO_PAY";
    case PaymentMethodType.GCASH:
      return "GCASH";
    case PaymentMethodType.IDEAL:
      return "IDEAL";
    case PaymentMethodType.INTERAC:
      return "INTERAC";
    case PaymentMethodType.INDOMARET:
      return "INDOMARET";
    case PaymentMethodType.KAKAO_PAY:
      return "KAKAO_PAY";
    case PaymentMethodType.LOCAL_BANK_REDIRECT:
      return "LOCAL_BANK_REDIRECT";
    case PaymentMethodType.MANDIRI_VA:
      return "MANDIRI_VA";
    case PaymentMethodType.KNET:
      return "KNET";
    case PaymentMethodType.MB_WAY:
      return "MB_WAY";
    case PaymentMethodType.MOBILE_PAY:
      return "MOBILE_PAY";
    case PaymentMethodType.MOMO:
      return "MOMO";
    case PaymentMethodType.MOMO_ATM:
      return "MOMO_ATM";
    case PaymentMethodType.MULTIBANCO:
      return "MULTIBANCO";
    case PaymentMethodType.ONLINE_BANKING_THAILAND:
      return "ONLINE_BANKING_THAILAND";
    case PaymentMethodType.ONLINE_BANKING_CZECH_REPUBLIC:
      return "ONLINE_BANKING_CZECH_REPUBLIC";
    case PaymentMethodType.ONLINE_BANKING_FINLAND:
      return "ONLINE_BANKING_FINLAND";
    case PaymentMethodType.ONLINE_BANKING_FPX:
      return "ONLINE_BANKING_FPX";
    case PaymentMethodType.ONLINE_BANKING_POLAND:
      return "ONLINE_BANKING_POLAND";
    case PaymentMethodType.ONLINE_BANKING_SLOVAKIA:
      return "ONLINE_BANKING_SLOVAKIA";
    case PaymentMethodType.OXXO:
      return "OXXO";
    case PaymentMethodType.PAGO_EFECTIVO:
      return "PAGO_EFECTIVO";
    case PaymentMethodType.PERMATA_BANK_TRANSFER:
      return "PERMATA_BANK_TRANSFER";
    case PaymentMethodType.OPEN_BANKING_UK:
      return "OPEN_BANKING_UK";
    case PaymentMethodType.PAY_BRIGHT:
      return "PAY_BRIGHT";
    case PaymentMethodType.PAZE:
      return "PAZE";
    case PaymentMethodType.PIX:
      return "PIX";
    case PaymentMethodType.PAY_SAFE_CARD:
      return "PAY_SAFE_CARD";
    case PaymentMethodType.PRZELEWY24:
      return "PRZELEWY24";
    case PaymentMethodType.PROMPT_PAY:
      return "PROMPT_PAY";
    case PaymentMethodType.PSE:
      return "PSE";
    case PaymentMethodType.RED_COMPRA:
      return "RED_COMPRA";
    case PaymentMethodType.RED_PAGOS:
      return "RED_PAGOS";
    case PaymentMethodType.SAMSUNG_PAY:
      return "SAMSUNG_PAY";
    case PaymentMethodType.SEPA:
      return "SEPA";
    case PaymentMethodType.SEPA_BANK_TRANSFER:
      return "SEPA_BANK_TRANSFER";
    case PaymentMethodType.SOFORT:
      return "SOFORT";
    case PaymentMethodType.SWISH:
      return "SWISH";
    case PaymentMethodType.TOUCH_N_GO:
      return "TOUCH_N_GO";
    case PaymentMethodType.TRUSTLY:
      return "TRUSTLY";
    case PaymentMethodType.TWINT:
      return "TWINT";
    case PaymentMethodType.UPI_COLLECT:
      return "UPI_COLLECT";
    case PaymentMethodType.UPI_INTENT:
      return "UPI_INTENT";
    case PaymentMethodType.VIPPS:
      return "VIPPS";
    case PaymentMethodType.VIET_QR:
      return "VIET_QR";
    case PaymentMethodType.VENMO:
      return "VENMO";
    case PaymentMethodType.WALLEY:
      return "WALLEY";
    case PaymentMethodType.WE_CHAT_PAY:
      return "WE_CHAT_PAY";
    case PaymentMethodType.SEVEN_ELEVEN:
      return "SEVEN_ELEVEN";
    case PaymentMethodType.LAWSON:
      return "LAWSON";
    case PaymentMethodType.MINI_STOP:
      return "MINI_STOP";
    case PaymentMethodType.FAMILY_MART:
      return "FAMILY_MART";
    case PaymentMethodType.SEICOMART:
      return "SEICOMART";
    case PaymentMethodType.PAY_EASY:
      return "PAY_EASY";
    case PaymentMethodType.LOCAL_BANK_TRANSFER:
      return "LOCAL_BANK_TRANSFER";
    case PaymentMethodType.OPEN_BANKING_PIS:
      return "OPEN_BANKING_PIS";
    case PaymentMethodType.DIRECT_CARRIER_BILLING:
      return "DIRECT_CARRIER_BILLING";
    case PaymentMethodType.INSTANT_BANK_TRANSFER:
      return "INSTANT_BANK_TRANSFER";
    case PaymentMethodType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CardNetwork {
  VISA = 0,
  MASTERCARD = 1,
  AMERICAN_EXPRESS = 2,
  JCB = 3,
  DINERS_CLUB = 4,
  DISCOVER = 5,
  CARTES_BANCAIRES = 6,
  UNION_PAY = 7,
  RU_PAY = 8,
  MAESTRO = 9,
  UNRECOGNIZED = -1,
}

export function cardNetworkFromJSON(object: any): CardNetwork {
  switch (object) {
    case 0:
    case "VISA":
      return CardNetwork.VISA;
    case 1:
    case "MASTERCARD":
      return CardNetwork.MASTERCARD;
    case 2:
    case "AMERICAN_EXPRESS":
      return CardNetwork.AMERICAN_EXPRESS;
    case 3:
    case "JCB":
      return CardNetwork.JCB;
    case 4:
    case "DINERS_CLUB":
      return CardNetwork.DINERS_CLUB;
    case 5:
    case "DISCOVER":
      return CardNetwork.DISCOVER;
    case 6:
    case "CARTES_BANCAIRES":
      return CardNetwork.CARTES_BANCAIRES;
    case 7:
    case "UNION_PAY":
      return CardNetwork.UNION_PAY;
    case 8:
    case "RU_PAY":
      return CardNetwork.RU_PAY;
    case 9:
    case "MAESTRO":
      return CardNetwork.MAESTRO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CardNetwork.UNRECOGNIZED;
  }
}

export function cardNetworkToJSON(object: CardNetwork): string {
  switch (object) {
    case CardNetwork.VISA:
      return "VISA";
    case CardNetwork.MASTERCARD:
      return "MASTERCARD";
    case CardNetwork.AMERICAN_EXPRESS:
      return "AMERICAN_EXPRESS";
    case CardNetwork.JCB:
      return "JCB";
    case CardNetwork.DINERS_CLUB:
      return "DINERS_CLUB";
    case CardNetwork.DISCOVER:
      return "DISCOVER";
    case CardNetwork.CARTES_BANCAIRES:
      return "CARTES_BANCAIRES";
    case CardNetwork.UNION_PAY:
      return "UNION_PAY";
    case CardNetwork.RU_PAY:
      return "RU_PAY";
    case CardNetwork.MAESTRO:
      return "MAESTRO";
    case CardNetwork.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AuthenticationType {
  THREE_DS = 0,
  NO_THREE_DS = 1,
  UNRECOGNIZED = -1,
}

export function authenticationTypeFromJSON(object: any): AuthenticationType {
  switch (object) {
    case 0:
    case "THREE_DS":
      return AuthenticationType.THREE_DS;
    case 1:
    case "NO_THREE_DS":
      return AuthenticationType.NO_THREE_DS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthenticationType.UNRECOGNIZED;
  }
}

export function authenticationTypeToJSON(object: AuthenticationType): string {
  switch (object) {
    case AuthenticationType.THREE_DS:
      return "THREE_DS";
    case AuthenticationType.NO_THREE_DS:
      return "NO_THREE_DS";
    case AuthenticationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PaymentMethod {
  CARD = 0,
  UNRECOGNIZED = -1,
}

export function paymentMethodFromJSON(object: any): PaymentMethod {
  switch (object) {
    case 0:
    case "CARD":
      return PaymentMethod.CARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentMethod.UNRECOGNIZED;
  }
}

export function paymentMethodToJSON(object: PaymentMethod): string {
  switch (object) {
    case PaymentMethod.CARD:
      return "CARD";
    case PaymentMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Country Alpha-2 code enumeration */
export enum CountryAlpha2 {
  /** US - Default value must be first (value 0) */
  US = 0,
  AF = 1,
  AX = 2,
  AL = 3,
  DZ = 4,
  AS = 5,
  AD = 6,
  AO = 7,
  AI = 8,
  AQ = 9,
  AG = 10,
  AR = 11,
  AM = 12,
  AW = 13,
  AU = 14,
  AT = 15,
  AZ = 16,
  BS = 17,
  BH = 18,
  BD = 19,
  BB = 20,
  BY = 21,
  BE = 22,
  BZ = 23,
  BJ = 24,
  BM = 25,
  BT = 26,
  BO = 27,
  BQ = 28,
  BA = 29,
  BW = 30,
  BV = 31,
  BR = 32,
  IO = 33,
  BN = 34,
  BG = 35,
  BF = 36,
  BI = 37,
  KH = 38,
  CM = 39,
  CA = 40,
  CV = 41,
  KY = 42,
  CF = 43,
  TD = 44,
  CL = 45,
  CN = 46,
  CX = 47,
  CC = 48,
  CO = 49,
  KM = 50,
  CG = 51,
  CD = 52,
  CK = 53,
  CR = 54,
  CI = 55,
  HR = 56,
  CU = 57,
  CW = 58,
  CY = 59,
  CZ = 60,
  DK = 61,
  DJ = 62,
  DM = 63,
  DO = 64,
  EC = 65,
  EG = 66,
  SV = 67,
  GQ = 68,
  ER = 69,
  EE = 70,
  ET = 71,
  FK = 72,
  FO = 73,
  FJ = 74,
  FI = 75,
  FR = 76,
  GF = 77,
  PF = 78,
  TF = 79,
  GA = 80,
  GM = 81,
  GE = 82,
  DE = 83,
  GH = 84,
  GI = 85,
  GR = 86,
  GL = 87,
  GD = 88,
  GP = 89,
  GU = 90,
  GT = 91,
  GG = 92,
  GN = 93,
  GW = 94,
  GY = 95,
  HT = 96,
  HM = 97,
  VA = 98,
  HN = 99,
  HK = 100,
  HU = 101,
  IS = 102,
  IN = 103,
  ID = 104,
  IR = 105,
  IQ = 106,
  IE = 107,
  IM = 108,
  IL = 109,
  IT = 110,
  JM = 111,
  JP = 112,
  JE = 113,
  JO = 114,
  KZ = 115,
  KE = 116,
  KI = 117,
  KP = 118,
  KR = 119,
  KW = 120,
  KG = 121,
  LA = 122,
  LV = 123,
  LB = 124,
  LS = 125,
  LR = 126,
  LY = 127,
  LI = 128,
  LT = 129,
  LU = 130,
  MO = 131,
  MK = 132,
  MG = 133,
  MW = 134,
  MY = 135,
  MV = 136,
  ML = 137,
  MT = 138,
  MH = 139,
  MQ = 140,
  MR = 141,
  MU = 142,
  YT = 143,
  MX = 144,
  FM = 145,
  MD = 146,
  MC = 147,
  MN = 148,
  ME = 149,
  MS = 150,
  MA = 151,
  MZ = 152,
  MM = 153,
  NA = 154,
  NR = 155,
  NP = 156,
  NL = 157,
  NC = 158,
  NZ = 159,
  NI = 160,
  NE = 161,
  NG = 162,
  NU = 163,
  NF = 164,
  MP = 165,
  NO = 166,
  OM = 167,
  PK = 168,
  PW = 169,
  PS = 170,
  PA = 171,
  PG = 172,
  PY = 173,
  PE = 174,
  PH = 175,
  PN = 176,
  PL = 177,
  PT = 178,
  PR = 179,
  QA = 180,
  RE = 181,
  RO = 182,
  RU = 183,
  RW = 184,
  BL = 185,
  SH = 186,
  KN = 187,
  LC = 188,
  MF = 189,
  PM = 190,
  VC = 191,
  WS = 192,
  SM = 193,
  ST = 194,
  SA = 195,
  SN = 196,
  RS = 197,
  SC = 198,
  SL = 199,
  SG = 200,
  SX = 201,
  SK = 202,
  SI = 203,
  SB = 204,
  SO = 205,
  ZA = 206,
  GS = 207,
  SS = 208,
  ES = 209,
  LK = 210,
  SD = 211,
  SR = 212,
  SJ = 213,
  SZ = 214,
  SE = 215,
  CH = 216,
  SY = 217,
  TW = 218,
  TJ = 219,
  TZ = 220,
  TH = 221,
  TL = 222,
  TG = 223,
  TK = 224,
  TO = 225,
  TT = 226,
  TN = 227,
  TR = 228,
  TM = 229,
  TC = 230,
  TV = 231,
  UG = 232,
  UA = 233,
  AE = 234,
  GB = 235,
  UM = 236,
  UY = 237,
  UZ = 238,
  VU = 239,
  VE = 240,
  VN = 241,
  VG = 242,
  VI = 243,
  WF = 244,
  EH = 245,
  YE = 246,
  ZM = 247,
  ZW = 248,
  UNRECOGNIZED = -1,
}

export function countryAlpha2FromJSON(object: any): CountryAlpha2 {
  switch (object) {
    case 0:
    case "US":
      return CountryAlpha2.US;
    case 1:
    case "AF":
      return CountryAlpha2.AF;
    case 2:
    case "AX":
      return CountryAlpha2.AX;
    case 3:
    case "AL":
      return CountryAlpha2.AL;
    case 4:
    case "DZ":
      return CountryAlpha2.DZ;
    case 5:
    case "AS":
      return CountryAlpha2.AS;
    case 6:
    case "AD":
      return CountryAlpha2.AD;
    case 7:
    case "AO":
      return CountryAlpha2.AO;
    case 8:
    case "AI":
      return CountryAlpha2.AI;
    case 9:
    case "AQ":
      return CountryAlpha2.AQ;
    case 10:
    case "AG":
      return CountryAlpha2.AG;
    case 11:
    case "AR":
      return CountryAlpha2.AR;
    case 12:
    case "AM":
      return CountryAlpha2.AM;
    case 13:
    case "AW":
      return CountryAlpha2.AW;
    case 14:
    case "AU":
      return CountryAlpha2.AU;
    case 15:
    case "AT":
      return CountryAlpha2.AT;
    case 16:
    case "AZ":
      return CountryAlpha2.AZ;
    case 17:
    case "BS":
      return CountryAlpha2.BS;
    case 18:
    case "BH":
      return CountryAlpha2.BH;
    case 19:
    case "BD":
      return CountryAlpha2.BD;
    case 20:
    case "BB":
      return CountryAlpha2.BB;
    case 21:
    case "BY":
      return CountryAlpha2.BY;
    case 22:
    case "BE":
      return CountryAlpha2.BE;
    case 23:
    case "BZ":
      return CountryAlpha2.BZ;
    case 24:
    case "BJ":
      return CountryAlpha2.BJ;
    case 25:
    case "BM":
      return CountryAlpha2.BM;
    case 26:
    case "BT":
      return CountryAlpha2.BT;
    case 27:
    case "BO":
      return CountryAlpha2.BO;
    case 28:
    case "BQ":
      return CountryAlpha2.BQ;
    case 29:
    case "BA":
      return CountryAlpha2.BA;
    case 30:
    case "BW":
      return CountryAlpha2.BW;
    case 31:
    case "BV":
      return CountryAlpha2.BV;
    case 32:
    case "BR":
      return CountryAlpha2.BR;
    case 33:
    case "IO":
      return CountryAlpha2.IO;
    case 34:
    case "BN":
      return CountryAlpha2.BN;
    case 35:
    case "BG":
      return CountryAlpha2.BG;
    case 36:
    case "BF":
      return CountryAlpha2.BF;
    case 37:
    case "BI":
      return CountryAlpha2.BI;
    case 38:
    case "KH":
      return CountryAlpha2.KH;
    case 39:
    case "CM":
      return CountryAlpha2.CM;
    case 40:
    case "CA":
      return CountryAlpha2.CA;
    case 41:
    case "CV":
      return CountryAlpha2.CV;
    case 42:
    case "KY":
      return CountryAlpha2.KY;
    case 43:
    case "CF":
      return CountryAlpha2.CF;
    case 44:
    case "TD":
      return CountryAlpha2.TD;
    case 45:
    case "CL":
      return CountryAlpha2.CL;
    case 46:
    case "CN":
      return CountryAlpha2.CN;
    case 47:
    case "CX":
      return CountryAlpha2.CX;
    case 48:
    case "CC":
      return CountryAlpha2.CC;
    case 49:
    case "CO":
      return CountryAlpha2.CO;
    case 50:
    case "KM":
      return CountryAlpha2.KM;
    case 51:
    case "CG":
      return CountryAlpha2.CG;
    case 52:
    case "CD":
      return CountryAlpha2.CD;
    case 53:
    case "CK":
      return CountryAlpha2.CK;
    case 54:
    case "CR":
      return CountryAlpha2.CR;
    case 55:
    case "CI":
      return CountryAlpha2.CI;
    case 56:
    case "HR":
      return CountryAlpha2.HR;
    case 57:
    case "CU":
      return CountryAlpha2.CU;
    case 58:
    case "CW":
      return CountryAlpha2.CW;
    case 59:
    case "CY":
      return CountryAlpha2.CY;
    case 60:
    case "CZ":
      return CountryAlpha2.CZ;
    case 61:
    case "DK":
      return CountryAlpha2.DK;
    case 62:
    case "DJ":
      return CountryAlpha2.DJ;
    case 63:
    case "DM":
      return CountryAlpha2.DM;
    case 64:
    case "DO":
      return CountryAlpha2.DO;
    case 65:
    case "EC":
      return CountryAlpha2.EC;
    case 66:
    case "EG":
      return CountryAlpha2.EG;
    case 67:
    case "SV":
      return CountryAlpha2.SV;
    case 68:
    case "GQ":
      return CountryAlpha2.GQ;
    case 69:
    case "ER":
      return CountryAlpha2.ER;
    case 70:
    case "EE":
      return CountryAlpha2.EE;
    case 71:
    case "ET":
      return CountryAlpha2.ET;
    case 72:
    case "FK":
      return CountryAlpha2.FK;
    case 73:
    case "FO":
      return CountryAlpha2.FO;
    case 74:
    case "FJ":
      return CountryAlpha2.FJ;
    case 75:
    case "FI":
      return CountryAlpha2.FI;
    case 76:
    case "FR":
      return CountryAlpha2.FR;
    case 77:
    case "GF":
      return CountryAlpha2.GF;
    case 78:
    case "PF":
      return CountryAlpha2.PF;
    case 79:
    case "TF":
      return CountryAlpha2.TF;
    case 80:
    case "GA":
      return CountryAlpha2.GA;
    case 81:
    case "GM":
      return CountryAlpha2.GM;
    case 82:
    case "GE":
      return CountryAlpha2.GE;
    case 83:
    case "DE":
      return CountryAlpha2.DE;
    case 84:
    case "GH":
      return CountryAlpha2.GH;
    case 85:
    case "GI":
      return CountryAlpha2.GI;
    case 86:
    case "GR":
      return CountryAlpha2.GR;
    case 87:
    case "GL":
      return CountryAlpha2.GL;
    case 88:
    case "GD":
      return CountryAlpha2.GD;
    case 89:
    case "GP":
      return CountryAlpha2.GP;
    case 90:
    case "GU":
      return CountryAlpha2.GU;
    case 91:
    case "GT":
      return CountryAlpha2.GT;
    case 92:
    case "GG":
      return CountryAlpha2.GG;
    case 93:
    case "GN":
      return CountryAlpha2.GN;
    case 94:
    case "GW":
      return CountryAlpha2.GW;
    case 95:
    case "GY":
      return CountryAlpha2.GY;
    case 96:
    case "HT":
      return CountryAlpha2.HT;
    case 97:
    case "HM":
      return CountryAlpha2.HM;
    case 98:
    case "VA":
      return CountryAlpha2.VA;
    case 99:
    case "HN":
      return CountryAlpha2.HN;
    case 100:
    case "HK":
      return CountryAlpha2.HK;
    case 101:
    case "HU":
      return CountryAlpha2.HU;
    case 102:
    case "IS":
      return CountryAlpha2.IS;
    case 103:
    case "IN":
      return CountryAlpha2.IN;
    case 104:
    case "ID":
      return CountryAlpha2.ID;
    case 105:
    case "IR":
      return CountryAlpha2.IR;
    case 106:
    case "IQ":
      return CountryAlpha2.IQ;
    case 107:
    case "IE":
      return CountryAlpha2.IE;
    case 108:
    case "IM":
      return CountryAlpha2.IM;
    case 109:
    case "IL":
      return CountryAlpha2.IL;
    case 110:
    case "IT":
      return CountryAlpha2.IT;
    case 111:
    case "JM":
      return CountryAlpha2.JM;
    case 112:
    case "JP":
      return CountryAlpha2.JP;
    case 113:
    case "JE":
      return CountryAlpha2.JE;
    case 114:
    case "JO":
      return CountryAlpha2.JO;
    case 115:
    case "KZ":
      return CountryAlpha2.KZ;
    case 116:
    case "KE":
      return CountryAlpha2.KE;
    case 117:
    case "KI":
      return CountryAlpha2.KI;
    case 118:
    case "KP":
      return CountryAlpha2.KP;
    case 119:
    case "KR":
      return CountryAlpha2.KR;
    case 120:
    case "KW":
      return CountryAlpha2.KW;
    case 121:
    case "KG":
      return CountryAlpha2.KG;
    case 122:
    case "LA":
      return CountryAlpha2.LA;
    case 123:
    case "LV":
      return CountryAlpha2.LV;
    case 124:
    case "LB":
      return CountryAlpha2.LB;
    case 125:
    case "LS":
      return CountryAlpha2.LS;
    case 126:
    case "LR":
      return CountryAlpha2.LR;
    case 127:
    case "LY":
      return CountryAlpha2.LY;
    case 128:
    case "LI":
      return CountryAlpha2.LI;
    case 129:
    case "LT":
      return CountryAlpha2.LT;
    case 130:
    case "LU":
      return CountryAlpha2.LU;
    case 131:
    case "MO":
      return CountryAlpha2.MO;
    case 132:
    case "MK":
      return CountryAlpha2.MK;
    case 133:
    case "MG":
      return CountryAlpha2.MG;
    case 134:
    case "MW":
      return CountryAlpha2.MW;
    case 135:
    case "MY":
      return CountryAlpha2.MY;
    case 136:
    case "MV":
      return CountryAlpha2.MV;
    case 137:
    case "ML":
      return CountryAlpha2.ML;
    case 138:
    case "MT":
      return CountryAlpha2.MT;
    case 139:
    case "MH":
      return CountryAlpha2.MH;
    case 140:
    case "MQ":
      return CountryAlpha2.MQ;
    case 141:
    case "MR":
      return CountryAlpha2.MR;
    case 142:
    case "MU":
      return CountryAlpha2.MU;
    case 143:
    case "YT":
      return CountryAlpha2.YT;
    case 144:
    case "MX":
      return CountryAlpha2.MX;
    case 145:
    case "FM":
      return CountryAlpha2.FM;
    case 146:
    case "MD":
      return CountryAlpha2.MD;
    case 147:
    case "MC":
      return CountryAlpha2.MC;
    case 148:
    case "MN":
      return CountryAlpha2.MN;
    case 149:
    case "ME":
      return CountryAlpha2.ME;
    case 150:
    case "MS":
      return CountryAlpha2.MS;
    case 151:
    case "MA":
      return CountryAlpha2.MA;
    case 152:
    case "MZ":
      return CountryAlpha2.MZ;
    case 153:
    case "MM":
      return CountryAlpha2.MM;
    case 154:
    case "NA":
      return CountryAlpha2.NA;
    case 155:
    case "NR":
      return CountryAlpha2.NR;
    case 156:
    case "NP":
      return CountryAlpha2.NP;
    case 157:
    case "NL":
      return CountryAlpha2.NL;
    case 158:
    case "NC":
      return CountryAlpha2.NC;
    case 159:
    case "NZ":
      return CountryAlpha2.NZ;
    case 160:
    case "NI":
      return CountryAlpha2.NI;
    case 161:
    case "NE":
      return CountryAlpha2.NE;
    case 162:
    case "NG":
      return CountryAlpha2.NG;
    case 163:
    case "NU":
      return CountryAlpha2.NU;
    case 164:
    case "NF":
      return CountryAlpha2.NF;
    case 165:
    case "MP":
      return CountryAlpha2.MP;
    case 166:
    case "NO":
      return CountryAlpha2.NO;
    case 167:
    case "OM":
      return CountryAlpha2.OM;
    case 168:
    case "PK":
      return CountryAlpha2.PK;
    case 169:
    case "PW":
      return CountryAlpha2.PW;
    case 170:
    case "PS":
      return CountryAlpha2.PS;
    case 171:
    case "PA":
      return CountryAlpha2.PA;
    case 172:
    case "PG":
      return CountryAlpha2.PG;
    case 173:
    case "PY":
      return CountryAlpha2.PY;
    case 174:
    case "PE":
      return CountryAlpha2.PE;
    case 175:
    case "PH":
      return CountryAlpha2.PH;
    case 176:
    case "PN":
      return CountryAlpha2.PN;
    case 177:
    case "PL":
      return CountryAlpha2.PL;
    case 178:
    case "PT":
      return CountryAlpha2.PT;
    case 179:
    case "PR":
      return CountryAlpha2.PR;
    case 180:
    case "QA":
      return CountryAlpha2.QA;
    case 181:
    case "RE":
      return CountryAlpha2.RE;
    case 182:
    case "RO":
      return CountryAlpha2.RO;
    case 183:
    case "RU":
      return CountryAlpha2.RU;
    case 184:
    case "RW":
      return CountryAlpha2.RW;
    case 185:
    case "BL":
      return CountryAlpha2.BL;
    case 186:
    case "SH":
      return CountryAlpha2.SH;
    case 187:
    case "KN":
      return CountryAlpha2.KN;
    case 188:
    case "LC":
      return CountryAlpha2.LC;
    case 189:
    case "MF":
      return CountryAlpha2.MF;
    case 190:
    case "PM":
      return CountryAlpha2.PM;
    case 191:
    case "VC":
      return CountryAlpha2.VC;
    case 192:
    case "WS":
      return CountryAlpha2.WS;
    case 193:
    case "SM":
      return CountryAlpha2.SM;
    case 194:
    case "ST":
      return CountryAlpha2.ST;
    case 195:
    case "SA":
      return CountryAlpha2.SA;
    case 196:
    case "SN":
      return CountryAlpha2.SN;
    case 197:
    case "RS":
      return CountryAlpha2.RS;
    case 198:
    case "SC":
      return CountryAlpha2.SC;
    case 199:
    case "SL":
      return CountryAlpha2.SL;
    case 200:
    case "SG":
      return CountryAlpha2.SG;
    case 201:
    case "SX":
      return CountryAlpha2.SX;
    case 202:
    case "SK":
      return CountryAlpha2.SK;
    case 203:
    case "SI":
      return CountryAlpha2.SI;
    case 204:
    case "SB":
      return CountryAlpha2.SB;
    case 205:
    case "SO":
      return CountryAlpha2.SO;
    case 206:
    case "ZA":
      return CountryAlpha2.ZA;
    case 207:
    case "GS":
      return CountryAlpha2.GS;
    case 208:
    case "SS":
      return CountryAlpha2.SS;
    case 209:
    case "ES":
      return CountryAlpha2.ES;
    case 210:
    case "LK":
      return CountryAlpha2.LK;
    case 211:
    case "SD":
      return CountryAlpha2.SD;
    case 212:
    case "SR":
      return CountryAlpha2.SR;
    case 213:
    case "SJ":
      return CountryAlpha2.SJ;
    case 214:
    case "SZ":
      return CountryAlpha2.SZ;
    case 215:
    case "SE":
      return CountryAlpha2.SE;
    case 216:
    case "CH":
      return CountryAlpha2.CH;
    case 217:
    case "SY":
      return CountryAlpha2.SY;
    case 218:
    case "TW":
      return CountryAlpha2.TW;
    case 219:
    case "TJ":
      return CountryAlpha2.TJ;
    case 220:
    case "TZ":
      return CountryAlpha2.TZ;
    case 221:
    case "TH":
      return CountryAlpha2.TH;
    case 222:
    case "TL":
      return CountryAlpha2.TL;
    case 223:
    case "TG":
      return CountryAlpha2.TG;
    case 224:
    case "TK":
      return CountryAlpha2.TK;
    case 225:
    case "TO":
      return CountryAlpha2.TO;
    case 226:
    case "TT":
      return CountryAlpha2.TT;
    case 227:
    case "TN":
      return CountryAlpha2.TN;
    case 228:
    case "TR":
      return CountryAlpha2.TR;
    case 229:
    case "TM":
      return CountryAlpha2.TM;
    case 230:
    case "TC":
      return CountryAlpha2.TC;
    case 231:
    case "TV":
      return CountryAlpha2.TV;
    case 232:
    case "UG":
      return CountryAlpha2.UG;
    case 233:
    case "UA":
      return CountryAlpha2.UA;
    case 234:
    case "AE":
      return CountryAlpha2.AE;
    case 235:
    case "GB":
      return CountryAlpha2.GB;
    case 236:
    case "UM":
      return CountryAlpha2.UM;
    case 237:
    case "UY":
      return CountryAlpha2.UY;
    case 238:
    case "UZ":
      return CountryAlpha2.UZ;
    case 239:
    case "VU":
      return CountryAlpha2.VU;
    case 240:
    case "VE":
      return CountryAlpha2.VE;
    case 241:
    case "VN":
      return CountryAlpha2.VN;
    case 242:
    case "VG":
      return CountryAlpha2.VG;
    case 243:
    case "VI":
      return CountryAlpha2.VI;
    case 244:
    case "WF":
      return CountryAlpha2.WF;
    case 245:
    case "EH":
      return CountryAlpha2.EH;
    case 246:
    case "YE":
      return CountryAlpha2.YE;
    case 247:
    case "ZM":
      return CountryAlpha2.ZM;
    case 248:
    case "ZW":
      return CountryAlpha2.ZW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CountryAlpha2.UNRECOGNIZED;
  }
}

export function countryAlpha2ToJSON(object: CountryAlpha2): string {
  switch (object) {
    case CountryAlpha2.US:
      return "US";
    case CountryAlpha2.AF:
      return "AF";
    case CountryAlpha2.AX:
      return "AX";
    case CountryAlpha2.AL:
      return "AL";
    case CountryAlpha2.DZ:
      return "DZ";
    case CountryAlpha2.AS:
      return "AS";
    case CountryAlpha2.AD:
      return "AD";
    case CountryAlpha2.AO:
      return "AO";
    case CountryAlpha2.AI:
      return "AI";
    case CountryAlpha2.AQ:
      return "AQ";
    case CountryAlpha2.AG:
      return "AG";
    case CountryAlpha2.AR:
      return "AR";
    case CountryAlpha2.AM:
      return "AM";
    case CountryAlpha2.AW:
      return "AW";
    case CountryAlpha2.AU:
      return "AU";
    case CountryAlpha2.AT:
      return "AT";
    case CountryAlpha2.AZ:
      return "AZ";
    case CountryAlpha2.BS:
      return "BS";
    case CountryAlpha2.BH:
      return "BH";
    case CountryAlpha2.BD:
      return "BD";
    case CountryAlpha2.BB:
      return "BB";
    case CountryAlpha2.BY:
      return "BY";
    case CountryAlpha2.BE:
      return "BE";
    case CountryAlpha2.BZ:
      return "BZ";
    case CountryAlpha2.BJ:
      return "BJ";
    case CountryAlpha2.BM:
      return "BM";
    case CountryAlpha2.BT:
      return "BT";
    case CountryAlpha2.BO:
      return "BO";
    case CountryAlpha2.BQ:
      return "BQ";
    case CountryAlpha2.BA:
      return "BA";
    case CountryAlpha2.BW:
      return "BW";
    case CountryAlpha2.BV:
      return "BV";
    case CountryAlpha2.BR:
      return "BR";
    case CountryAlpha2.IO:
      return "IO";
    case CountryAlpha2.BN:
      return "BN";
    case CountryAlpha2.BG:
      return "BG";
    case CountryAlpha2.BF:
      return "BF";
    case CountryAlpha2.BI:
      return "BI";
    case CountryAlpha2.KH:
      return "KH";
    case CountryAlpha2.CM:
      return "CM";
    case CountryAlpha2.CA:
      return "CA";
    case CountryAlpha2.CV:
      return "CV";
    case CountryAlpha2.KY:
      return "KY";
    case CountryAlpha2.CF:
      return "CF";
    case CountryAlpha2.TD:
      return "TD";
    case CountryAlpha2.CL:
      return "CL";
    case CountryAlpha2.CN:
      return "CN";
    case CountryAlpha2.CX:
      return "CX";
    case CountryAlpha2.CC:
      return "CC";
    case CountryAlpha2.CO:
      return "CO";
    case CountryAlpha2.KM:
      return "KM";
    case CountryAlpha2.CG:
      return "CG";
    case CountryAlpha2.CD:
      return "CD";
    case CountryAlpha2.CK:
      return "CK";
    case CountryAlpha2.CR:
      return "CR";
    case CountryAlpha2.CI:
      return "CI";
    case CountryAlpha2.HR:
      return "HR";
    case CountryAlpha2.CU:
      return "CU";
    case CountryAlpha2.CW:
      return "CW";
    case CountryAlpha2.CY:
      return "CY";
    case CountryAlpha2.CZ:
      return "CZ";
    case CountryAlpha2.DK:
      return "DK";
    case CountryAlpha2.DJ:
      return "DJ";
    case CountryAlpha2.DM:
      return "DM";
    case CountryAlpha2.DO:
      return "DO";
    case CountryAlpha2.EC:
      return "EC";
    case CountryAlpha2.EG:
      return "EG";
    case CountryAlpha2.SV:
      return "SV";
    case CountryAlpha2.GQ:
      return "GQ";
    case CountryAlpha2.ER:
      return "ER";
    case CountryAlpha2.EE:
      return "EE";
    case CountryAlpha2.ET:
      return "ET";
    case CountryAlpha2.FK:
      return "FK";
    case CountryAlpha2.FO:
      return "FO";
    case CountryAlpha2.FJ:
      return "FJ";
    case CountryAlpha2.FI:
      return "FI";
    case CountryAlpha2.FR:
      return "FR";
    case CountryAlpha2.GF:
      return "GF";
    case CountryAlpha2.PF:
      return "PF";
    case CountryAlpha2.TF:
      return "TF";
    case CountryAlpha2.GA:
      return "GA";
    case CountryAlpha2.GM:
      return "GM";
    case CountryAlpha2.GE:
      return "GE";
    case CountryAlpha2.DE:
      return "DE";
    case CountryAlpha2.GH:
      return "GH";
    case CountryAlpha2.GI:
      return "GI";
    case CountryAlpha2.GR:
      return "GR";
    case CountryAlpha2.GL:
      return "GL";
    case CountryAlpha2.GD:
      return "GD";
    case CountryAlpha2.GP:
      return "GP";
    case CountryAlpha2.GU:
      return "GU";
    case CountryAlpha2.GT:
      return "GT";
    case CountryAlpha2.GG:
      return "GG";
    case CountryAlpha2.GN:
      return "GN";
    case CountryAlpha2.GW:
      return "GW";
    case CountryAlpha2.GY:
      return "GY";
    case CountryAlpha2.HT:
      return "HT";
    case CountryAlpha2.HM:
      return "HM";
    case CountryAlpha2.VA:
      return "VA";
    case CountryAlpha2.HN:
      return "HN";
    case CountryAlpha2.HK:
      return "HK";
    case CountryAlpha2.HU:
      return "HU";
    case CountryAlpha2.IS:
      return "IS";
    case CountryAlpha2.IN:
      return "IN";
    case CountryAlpha2.ID:
      return "ID";
    case CountryAlpha2.IR:
      return "IR";
    case CountryAlpha2.IQ:
      return "IQ";
    case CountryAlpha2.IE:
      return "IE";
    case CountryAlpha2.IM:
      return "IM";
    case CountryAlpha2.IL:
      return "IL";
    case CountryAlpha2.IT:
      return "IT";
    case CountryAlpha2.JM:
      return "JM";
    case CountryAlpha2.JP:
      return "JP";
    case CountryAlpha2.JE:
      return "JE";
    case CountryAlpha2.JO:
      return "JO";
    case CountryAlpha2.KZ:
      return "KZ";
    case CountryAlpha2.KE:
      return "KE";
    case CountryAlpha2.KI:
      return "KI";
    case CountryAlpha2.KP:
      return "KP";
    case CountryAlpha2.KR:
      return "KR";
    case CountryAlpha2.KW:
      return "KW";
    case CountryAlpha2.KG:
      return "KG";
    case CountryAlpha2.LA:
      return "LA";
    case CountryAlpha2.LV:
      return "LV";
    case CountryAlpha2.LB:
      return "LB";
    case CountryAlpha2.LS:
      return "LS";
    case CountryAlpha2.LR:
      return "LR";
    case CountryAlpha2.LY:
      return "LY";
    case CountryAlpha2.LI:
      return "LI";
    case CountryAlpha2.LT:
      return "LT";
    case CountryAlpha2.LU:
      return "LU";
    case CountryAlpha2.MO:
      return "MO";
    case CountryAlpha2.MK:
      return "MK";
    case CountryAlpha2.MG:
      return "MG";
    case CountryAlpha2.MW:
      return "MW";
    case CountryAlpha2.MY:
      return "MY";
    case CountryAlpha2.MV:
      return "MV";
    case CountryAlpha2.ML:
      return "ML";
    case CountryAlpha2.MT:
      return "MT";
    case CountryAlpha2.MH:
      return "MH";
    case CountryAlpha2.MQ:
      return "MQ";
    case CountryAlpha2.MR:
      return "MR";
    case CountryAlpha2.MU:
      return "MU";
    case CountryAlpha2.YT:
      return "YT";
    case CountryAlpha2.MX:
      return "MX";
    case CountryAlpha2.FM:
      return "FM";
    case CountryAlpha2.MD:
      return "MD";
    case CountryAlpha2.MC:
      return "MC";
    case CountryAlpha2.MN:
      return "MN";
    case CountryAlpha2.ME:
      return "ME";
    case CountryAlpha2.MS:
      return "MS";
    case CountryAlpha2.MA:
      return "MA";
    case CountryAlpha2.MZ:
      return "MZ";
    case CountryAlpha2.MM:
      return "MM";
    case CountryAlpha2.NA:
      return "NA";
    case CountryAlpha2.NR:
      return "NR";
    case CountryAlpha2.NP:
      return "NP";
    case CountryAlpha2.NL:
      return "NL";
    case CountryAlpha2.NC:
      return "NC";
    case CountryAlpha2.NZ:
      return "NZ";
    case CountryAlpha2.NI:
      return "NI";
    case CountryAlpha2.NE:
      return "NE";
    case CountryAlpha2.NG:
      return "NG";
    case CountryAlpha2.NU:
      return "NU";
    case CountryAlpha2.NF:
      return "NF";
    case CountryAlpha2.MP:
      return "MP";
    case CountryAlpha2.NO:
      return "NO";
    case CountryAlpha2.OM:
      return "OM";
    case CountryAlpha2.PK:
      return "PK";
    case CountryAlpha2.PW:
      return "PW";
    case CountryAlpha2.PS:
      return "PS";
    case CountryAlpha2.PA:
      return "PA";
    case CountryAlpha2.PG:
      return "PG";
    case CountryAlpha2.PY:
      return "PY";
    case CountryAlpha2.PE:
      return "PE";
    case CountryAlpha2.PH:
      return "PH";
    case CountryAlpha2.PN:
      return "PN";
    case CountryAlpha2.PL:
      return "PL";
    case CountryAlpha2.PT:
      return "PT";
    case CountryAlpha2.PR:
      return "PR";
    case CountryAlpha2.QA:
      return "QA";
    case CountryAlpha2.RE:
      return "RE";
    case CountryAlpha2.RO:
      return "RO";
    case CountryAlpha2.RU:
      return "RU";
    case CountryAlpha2.RW:
      return "RW";
    case CountryAlpha2.BL:
      return "BL";
    case CountryAlpha2.SH:
      return "SH";
    case CountryAlpha2.KN:
      return "KN";
    case CountryAlpha2.LC:
      return "LC";
    case CountryAlpha2.MF:
      return "MF";
    case CountryAlpha2.PM:
      return "PM";
    case CountryAlpha2.VC:
      return "VC";
    case CountryAlpha2.WS:
      return "WS";
    case CountryAlpha2.SM:
      return "SM";
    case CountryAlpha2.ST:
      return "ST";
    case CountryAlpha2.SA:
      return "SA";
    case CountryAlpha2.SN:
      return "SN";
    case CountryAlpha2.RS:
      return "RS";
    case CountryAlpha2.SC:
      return "SC";
    case CountryAlpha2.SL:
      return "SL";
    case CountryAlpha2.SG:
      return "SG";
    case CountryAlpha2.SX:
      return "SX";
    case CountryAlpha2.SK:
      return "SK";
    case CountryAlpha2.SI:
      return "SI";
    case CountryAlpha2.SB:
      return "SB";
    case CountryAlpha2.SO:
      return "SO";
    case CountryAlpha2.ZA:
      return "ZA";
    case CountryAlpha2.GS:
      return "GS";
    case CountryAlpha2.SS:
      return "SS";
    case CountryAlpha2.ES:
      return "ES";
    case CountryAlpha2.LK:
      return "LK";
    case CountryAlpha2.SD:
      return "SD";
    case CountryAlpha2.SR:
      return "SR";
    case CountryAlpha2.SJ:
      return "SJ";
    case CountryAlpha2.SZ:
      return "SZ";
    case CountryAlpha2.SE:
      return "SE";
    case CountryAlpha2.CH:
      return "CH";
    case CountryAlpha2.SY:
      return "SY";
    case CountryAlpha2.TW:
      return "TW";
    case CountryAlpha2.TJ:
      return "TJ";
    case CountryAlpha2.TZ:
      return "TZ";
    case CountryAlpha2.TH:
      return "TH";
    case CountryAlpha2.TL:
      return "TL";
    case CountryAlpha2.TG:
      return "TG";
    case CountryAlpha2.TK:
      return "TK";
    case CountryAlpha2.TO:
      return "TO";
    case CountryAlpha2.TT:
      return "TT";
    case CountryAlpha2.TN:
      return "TN";
    case CountryAlpha2.TR:
      return "TR";
    case CountryAlpha2.TM:
      return "TM";
    case CountryAlpha2.TC:
      return "TC";
    case CountryAlpha2.TV:
      return "TV";
    case CountryAlpha2.UG:
      return "UG";
    case CountryAlpha2.UA:
      return "UA";
    case CountryAlpha2.AE:
      return "AE";
    case CountryAlpha2.GB:
      return "GB";
    case CountryAlpha2.UM:
      return "UM";
    case CountryAlpha2.UY:
      return "UY";
    case CountryAlpha2.UZ:
      return "UZ";
    case CountryAlpha2.VU:
      return "VU";
    case CountryAlpha2.VE:
      return "VE";
    case CountryAlpha2.VN:
      return "VN";
    case CountryAlpha2.VG:
      return "VG";
    case CountryAlpha2.VI:
      return "VI";
    case CountryAlpha2.WF:
      return "WF";
    case CountryAlpha2.EH:
      return "EH";
    case CountryAlpha2.YE:
      return "YE";
    case CountryAlpha2.ZM:
      return "ZM";
    case CountryAlpha2.ZW:
      return "ZW";
    case CountryAlpha2.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AttemptStatus {
  STARTED = 0,
  AUTHENTICATION_FAILED = 1,
  ROUTER_DECLINED = 2,
  AUTHENTICATION_PENDING = 3,
  AUTHENTICATION_SUCCESSFUL = 4,
  AUTHORIZED = 5,
  AUTHORIZATION_FAILED = 6,
  CHARGED = 7,
  AUTHORIZING = 8,
  COD_INITIATED = 9,
  VOIDED = 10,
  VOID_INITIATED = 11,
  CAPTURE_INITIATED = 12,
  CAPTURE_FAILED = 13,
  VOID_FAILED = 14,
  AUTO_REFUNDED = 15,
  PARTIAL_CHARGED = 16,
  PARTIAL_CHARGED_AND_CHARGEABLE = 17,
  UNRESOLVED = 18,
  PENDING = 19,
  FAILURE = 20,
  PAYMENT_METHOD_AWAITED = 21,
  CONFIRMATION_AWAITED = 22,
  DEVICE_DATA_COLLECTION_PENDING = 23,
  UNRECOGNIZED = -1,
}

export function attemptStatusFromJSON(object: any): AttemptStatus {
  switch (object) {
    case 0:
    case "STARTED":
      return AttemptStatus.STARTED;
    case 1:
    case "AUTHENTICATION_FAILED":
      return AttemptStatus.AUTHENTICATION_FAILED;
    case 2:
    case "ROUTER_DECLINED":
      return AttemptStatus.ROUTER_DECLINED;
    case 3:
    case "AUTHENTICATION_PENDING":
      return AttemptStatus.AUTHENTICATION_PENDING;
    case 4:
    case "AUTHENTICATION_SUCCESSFUL":
      return AttemptStatus.AUTHENTICATION_SUCCESSFUL;
    case 5:
    case "AUTHORIZED":
      return AttemptStatus.AUTHORIZED;
    case 6:
    case "AUTHORIZATION_FAILED":
      return AttemptStatus.AUTHORIZATION_FAILED;
    case 7:
    case "CHARGED":
      return AttemptStatus.CHARGED;
    case 8:
    case "AUTHORIZING":
      return AttemptStatus.AUTHORIZING;
    case 9:
    case "COD_INITIATED":
      return AttemptStatus.COD_INITIATED;
    case 10:
    case "VOIDED":
      return AttemptStatus.VOIDED;
    case 11:
    case "VOID_INITIATED":
      return AttemptStatus.VOID_INITIATED;
    case 12:
    case "CAPTURE_INITIATED":
      return AttemptStatus.CAPTURE_INITIATED;
    case 13:
    case "CAPTURE_FAILED":
      return AttemptStatus.CAPTURE_FAILED;
    case 14:
    case "VOID_FAILED":
      return AttemptStatus.VOID_FAILED;
    case 15:
    case "AUTO_REFUNDED":
      return AttemptStatus.AUTO_REFUNDED;
    case 16:
    case "PARTIAL_CHARGED":
      return AttemptStatus.PARTIAL_CHARGED;
    case 17:
    case "PARTIAL_CHARGED_AND_CHARGEABLE":
      return AttemptStatus.PARTIAL_CHARGED_AND_CHARGEABLE;
    case 18:
    case "UNRESOLVED":
      return AttemptStatus.UNRESOLVED;
    case 19:
    case "PENDING":
      return AttemptStatus.PENDING;
    case 20:
    case "FAILURE":
      return AttemptStatus.FAILURE;
    case 21:
    case "PAYMENT_METHOD_AWAITED":
      return AttemptStatus.PAYMENT_METHOD_AWAITED;
    case 22:
    case "CONFIRMATION_AWAITED":
      return AttemptStatus.CONFIRMATION_AWAITED;
    case 23:
    case "DEVICE_DATA_COLLECTION_PENDING":
      return AttemptStatus.DEVICE_DATA_COLLECTION_PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttemptStatus.UNRECOGNIZED;
  }
}

export function attemptStatusToJSON(object: AttemptStatus): string {
  switch (object) {
    case AttemptStatus.STARTED:
      return "STARTED";
    case AttemptStatus.AUTHENTICATION_FAILED:
      return "AUTHENTICATION_FAILED";
    case AttemptStatus.ROUTER_DECLINED:
      return "ROUTER_DECLINED";
    case AttemptStatus.AUTHENTICATION_PENDING:
      return "AUTHENTICATION_PENDING";
    case AttemptStatus.AUTHENTICATION_SUCCESSFUL:
      return "AUTHENTICATION_SUCCESSFUL";
    case AttemptStatus.AUTHORIZED:
      return "AUTHORIZED";
    case AttemptStatus.AUTHORIZATION_FAILED:
      return "AUTHORIZATION_FAILED";
    case AttemptStatus.CHARGED:
      return "CHARGED";
    case AttemptStatus.AUTHORIZING:
      return "AUTHORIZING";
    case AttemptStatus.COD_INITIATED:
      return "COD_INITIATED";
    case AttemptStatus.VOIDED:
      return "VOIDED";
    case AttemptStatus.VOID_INITIATED:
      return "VOID_INITIATED";
    case AttemptStatus.CAPTURE_INITIATED:
      return "CAPTURE_INITIATED";
    case AttemptStatus.CAPTURE_FAILED:
      return "CAPTURE_FAILED";
    case AttemptStatus.VOID_FAILED:
      return "VOID_FAILED";
    case AttemptStatus.AUTO_REFUNDED:
      return "AUTO_REFUNDED";
    case AttemptStatus.PARTIAL_CHARGED:
      return "PARTIAL_CHARGED";
    case AttemptStatus.PARTIAL_CHARGED_AND_CHARGEABLE:
      return "PARTIAL_CHARGED_AND_CHARGEABLE";
    case AttemptStatus.UNRESOLVED:
      return "UNRESOLVED";
    case AttemptStatus.PENDING:
      return "PENDING";
    case AttemptStatus.FAILURE:
      return "FAILURE";
    case AttemptStatus.PAYMENT_METHOD_AWAITED:
      return "PAYMENT_METHOD_AWAITED";
    case AttemptStatus.CONFIRMATION_AWAITED:
      return "CONFIRMATION_AWAITED";
    case AttemptStatus.DEVICE_DATA_COLLECTION_PENDING:
      return "DEVICE_DATA_COLLECTION_PENDING";
    case AttemptStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RefundStatus {
  REFUND_FAILURE = 0,
  REFUND_MANUAL_REVIEW = 1,
  REFUND_PENDING = 2,
  REFUND_SUCCESS = 3,
  REFUND_TRANSACTION_FAILURE = 4,
  UNRECOGNIZED = -1,
}

export function refundStatusFromJSON(object: any): RefundStatus {
  switch (object) {
    case 0:
    case "REFUND_FAILURE":
      return RefundStatus.REFUND_FAILURE;
    case 1:
    case "REFUND_MANUAL_REVIEW":
      return RefundStatus.REFUND_MANUAL_REVIEW;
    case 2:
    case "REFUND_PENDING":
      return RefundStatus.REFUND_PENDING;
    case 3:
    case "REFUND_SUCCESS":
      return RefundStatus.REFUND_SUCCESS;
    case 4:
    case "REFUND_TRANSACTION_FAILURE":
      return RefundStatus.REFUND_TRANSACTION_FAILURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RefundStatus.UNRECOGNIZED;
  }
}

export function refundStatusToJSON(object: RefundStatus): string {
  switch (object) {
    case RefundStatus.REFUND_FAILURE:
      return "REFUND_FAILURE";
    case RefundStatus.REFUND_MANUAL_REVIEW:
      return "REFUND_MANUAL_REVIEW";
    case RefundStatus.REFUND_PENDING:
      return "REFUND_PENDING";
    case RefundStatus.REFUND_SUCCESS:
      return "REFUND_SUCCESS";
    case RefundStatus.REFUND_TRANSACTION_FAILURE:
      return "REFUND_TRANSACTION_FAILURE";
    case RefundStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PaymentsAuthorizeRequest {
  amount: number;
  currency: Currency;
  paymentMethod: PaymentMethod;
  paymentMethodData: PaymentMethodData | undefined;
  connectorCustomer?: string | undefined;
  address: PaymentAddress | undefined;
  authType: AuthenticationType;
  connectorMetaData?: Uint8Array | undefined;
  accessToken?: AccessToken | undefined;
  sessionToken?: string | undefined;
  paymentMethodToken?: PaymentMethodToken | undefined;
  connectorRequestReferenceId: string;
  orderTaxAmount?: number | undefined;
  email?: string | undefined;
  customerName?: string | undefined;
  captureMethod?: CaptureMethod | undefined;
  returnUrl?: string | undefined;
  webhookUrl?: string | undefined;
  completeAuthorizeUrl?: string | undefined;
  setupFutureUsage?: FutureUsage | undefined;
  offSession?: boolean | undefined;
  customerAcceptance?: CustomerAcceptance | undefined;
  browserInfo?: BrowserInformation | undefined;
  orderCategory?: string | undefined;
  enrolledFor3ds: boolean;
  paymentExperience?: PaymentExperience | undefined;
  paymentMethodType?: PaymentMethodType | undefined;
  requestIncrementalAuthorization: boolean;
  authenticationData?: AuthenticationData | undefined;
  requestExtendedAuthorization?: boolean | undefined;
  minorAmount: number;
  merchantOrderReferenceId?: string | undefined;
  shippingCost?: number | undefined;
}

export interface PaymentsAuthorizeResponse {
  resourceId: ResponseId | undefined;
  redirectionData?: RedirectForm | undefined;
  mandateReference?: MandateReference | undefined;
  networkTxnId?: string | undefined;
  connectorResponseReferenceId?: string | undefined;
  incrementalAuthorizationAllowed?: boolean | undefined;
  status: AttemptStatus;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface PaymentsSyncRequest {
  resourceId: string;
  connectorRequestReferenceId?: string | undefined;
}

export interface PaymentsSyncResponse {
  resourceId: ResponseId | undefined;
  status: AttemptStatus;
  mandateReference?: MandateReference | undefined;
  networkTxnId?: string | undefined;
  connectorResponseReferenceId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface RefundsSyncRequest {
  connectorRefundId: string;
  connectorTransactionId: string;
  refundReason?: string | undefined;
}

export interface RefundsSyncResponse {
  connectorRefundId?: string | undefined;
  status: RefundStatus;
  connectorResponseReferenceId?: string | undefined;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface PaymentsVoidRequest {
  connectorRequestReferenceId: string;
  cancellationReason?: string | undefined;
}

export interface PaymentsVoidResponse {
  resourceId: ResponseId | undefined;
  connectorResponseReferenceId?: string | undefined;
  status: AttemptStatus;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface IncomingWebhookRequest {
  requestDetails: RequestDetails | undefined;
  webhookSecrets?: ConnectorWebhookSecrets | undefined;
}

export interface IncomingWebhookResponse {
  eventType: EventType;
  content: WebhookResponseContent | undefined;
  sourceVerified: boolean;
}

export interface WebhookResponseContent {
  paymentsResponse?: PaymentsSyncResponse | undefined;
  refundsResponse?: RefundsSyncResponse | undefined;
}

export interface RequestDetails {
  method: Method;
  uri?: string | undefined;
  headers: { [key: string]: string };
  body: Uint8Array;
  queryParams?: string | undefined;
}

export interface RequestDetails_HeadersEntry {
  key: string;
  value: string;
}

export interface ConnectorWebhookSecrets {
  secret: string;
  additionalSecret?: string | undefined;
}

export interface RefundsRequest {
  refundId: string;
  connectorTransactionId: string;
  connectorRefundId?: string | undefined;
  currency: Currency;
  paymentAmount: number;
  reason?: string | undefined;
  webhookUrl?: string | undefined;
  refundAmount: number;
  connectorMetadata?: Uint8Array | undefined;
  refundConnectorMetadata?: Uint8Array | undefined;
  browserInfo?: BrowserInformation | undefined;
  minorPaymentAmount: number;
  minorRefundAmount: number;
  merchantAccountId?: string | undefined;
  captureMethod?: CaptureMethod | undefined;
}

export interface RefundsResponse {
  connectorRefundId?: string | undefined;
  refundStatus: RefundStatus;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

export interface ResponseId {
  connectorTransactionId?: string | undefined;
  encodedData?:
    | string
    | undefined;
  /** Using bool as a presence indicator for NoResponseId */
  noResponseId?: boolean | undefined;
}

export interface RedirectForm {
  form?: FormData | undefined;
  html?: HtmlData | undefined;
}

export interface FormData {
  endpoint: string;
  method: Method;
  formFields: { [key: string]: string };
}

export interface FormData_FormFieldsEntry {
  key: string;
  value: string;
}

export interface HtmlData {
  htmlData: string;
}

export interface MandateReference {
  connectorMandateId?: string | undefined;
}

export interface CustomerAcceptance {
  acceptanceType: AcceptanceType;
  /** ISO8601 formatted string */
  acceptedAt: string;
  online?: OnlineMandate | undefined;
}

export interface BrowserInformation {
  colorDepth?: number | undefined;
  javaEnabled?: boolean | undefined;
  javaScriptEnabled?: boolean | undefined;
  language?: string | undefined;
  screenHeight?: number | undefined;
  screenWidth?: number | undefined;
  timeZone?:
    | number
    | undefined;
  /** Using string for IP address */
  ipAddress?: string | undefined;
  acceptHeader?: string | undefined;
  userAgent?: string | undefined;
  osType?: string | undefined;
  osVersion?: string | undefined;
  deviceModel?: string | undefined;
  acceptLanguage?: string | undefined;
}

export interface PaymentMethodData {
  card?: Card | undefined;
}

export interface Card {
  cardNumber: string;
  cardExpMonth: string;
  cardExpYear: string;
  cardHolderName?: string | undefined;
  cardCvc: string;
  cardIssuer?: string | undefined;
  cardNetwork?: CardNetwork | undefined;
  cardType?: string | undefined;
  cardIssuingCountry?: string | undefined;
  bankCode?: string | undefined;
  nickName?: string | undefined;
}

export interface OnlineMandate {
  ipAddress?: string | undefined;
  userAgent: string;
}

export interface PhoneDetails {
  number?: string | undefined;
  countryCode?: string | undefined;
}

export interface AuthenticationData {
  eci?: string | undefined;
  cavv: string;
  threedsServerTransactionId?:
    | string
    | undefined;
  /** Using string for SemanticVersion */
  messageVersion?: string | undefined;
  dsTransId?: string | undefined;
}

export interface PaymentAddress {
  shipping?: Address | undefined;
  billing?: Address | undefined;
  unifiedPaymentMethodBilling?: Address | undefined;
  paymentMethodBilling?: Address | undefined;
}

export interface Address {
  address?: AddressDetails | undefined;
  phone?:
    | PhoneDetails
    | undefined;
  /** Using string for Email */
  email?: string | undefined;
}

export interface AddressDetails {
  city?: string | undefined;
  country?: CountryAlpha2 | undefined;
  line1?: string | undefined;
  line2?: string | undefined;
  line3?: string | undefined;
  zip?: string | undefined;
  state?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export interface AccessToken {
  token: string;
  expires: number;
}

export interface PaymentMethodToken {
  token: string;
}

export interface MultipleCaptureRequestData {
  captureSequence: number;
  captureReference: string;
}

export interface PaymentsCaptureRequest {
  connectorTransactionId: string;
  amountToCapture: number;
  currency: Currency;
  multipleCaptureData?: MultipleCaptureRequestData | undefined;
  connectorMetaData?: Uint8Array | undefined;
}

export interface PaymentsCaptureResponse {
  resourceId: ResponseId | undefined;
  connectorResponseReferenceId?: string | undefined;
  status: AttemptStatus;
  errorCode?: string | undefined;
  errorMessage?: string | undefined;
}

function createBasePaymentsAuthorizeRequest(): PaymentsAuthorizeRequest {
  return {
    amount: 0,
    currency: 0,
    paymentMethod: 0,
    paymentMethodData: undefined,
    connectorCustomer: undefined,
    address: undefined,
    authType: 0,
    connectorMetaData: undefined,
    accessToken: undefined,
    sessionToken: undefined,
    paymentMethodToken: undefined,
    connectorRequestReferenceId: "",
    orderTaxAmount: undefined,
    email: undefined,
    customerName: undefined,
    captureMethod: undefined,
    returnUrl: undefined,
    webhookUrl: undefined,
    completeAuthorizeUrl: undefined,
    setupFutureUsage: undefined,
    offSession: undefined,
    customerAcceptance: undefined,
    browserInfo: undefined,
    orderCategory: undefined,
    enrolledFor3ds: false,
    paymentExperience: undefined,
    paymentMethodType: undefined,
    requestIncrementalAuthorization: false,
    authenticationData: undefined,
    requestExtendedAuthorization: undefined,
    minorAmount: 0,
    merchantOrderReferenceId: undefined,
    shippingCost: undefined,
  };
}

export const PaymentsAuthorizeRequest: MessageFns<PaymentsAuthorizeRequest> = {
  encode(message: PaymentsAuthorizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== 0) {
      writer.uint32(80).int64(message.amount);
    }
    if (message.currency !== 0) {
      writer.uint32(120).int32(message.currency);
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(16).int32(message.paymentMethod);
    }
    if (message.paymentMethodData !== undefined) {
      PaymentMethodData.encode(message.paymentMethodData, writer.uint32(114).fork()).join();
    }
    if (message.connectorCustomer !== undefined) {
      writer.uint32(10).string(message.connectorCustomer);
    }
    if (message.address !== undefined) {
      PaymentAddress.encode(message.address, writer.uint32(26).fork()).join();
    }
    if (message.authType !== 0) {
      writer.uint32(32).int32(message.authType);
    }
    if (message.connectorMetaData !== undefined) {
      writer.uint32(42).bytes(message.connectorMetaData);
    }
    if (message.accessToken !== undefined) {
      AccessToken.encode(message.accessToken, writer.uint32(50).fork()).join();
    }
    if (message.sessionToken !== undefined) {
      writer.uint32(58).string(message.sessionToken);
    }
    if (message.paymentMethodToken !== undefined) {
      PaymentMethodToken.encode(message.paymentMethodToken, writer.uint32(66).fork()).join();
    }
    if (message.connectorRequestReferenceId !== "") {
      writer.uint32(74).string(message.connectorRequestReferenceId);
    }
    if (message.orderTaxAmount !== undefined) {
      writer.uint32(88).int64(message.orderTaxAmount);
    }
    if (message.email !== undefined) {
      writer.uint32(98).string(message.email);
    }
    if (message.customerName !== undefined) {
      writer.uint32(106).string(message.customerName);
    }
    if (message.captureMethod !== undefined) {
      writer.uint32(128).int32(message.captureMethod);
    }
    if (message.returnUrl !== undefined) {
      writer.uint32(138).string(message.returnUrl);
    }
    if (message.webhookUrl !== undefined) {
      writer.uint32(146).string(message.webhookUrl);
    }
    if (message.completeAuthorizeUrl !== undefined) {
      writer.uint32(154).string(message.completeAuthorizeUrl);
    }
    if (message.setupFutureUsage !== undefined) {
      writer.uint32(160).int32(message.setupFutureUsage);
    }
    if (message.offSession !== undefined) {
      writer.uint32(168).bool(message.offSession);
    }
    if (message.customerAcceptance !== undefined) {
      CustomerAcceptance.encode(message.customerAcceptance, writer.uint32(178).fork()).join();
    }
    if (message.browserInfo !== undefined) {
      BrowserInformation.encode(message.browserInfo, writer.uint32(186).fork()).join();
    }
    if (message.orderCategory !== undefined) {
      writer.uint32(194).string(message.orderCategory);
    }
    if (message.enrolledFor3ds !== false) {
      writer.uint32(200).bool(message.enrolledFor3ds);
    }
    if (message.paymentExperience !== undefined) {
      writer.uint32(208).int32(message.paymentExperience);
    }
    if (message.paymentMethodType !== undefined) {
      writer.uint32(216).int32(message.paymentMethodType);
    }
    if (message.requestIncrementalAuthorization !== false) {
      writer.uint32(224).bool(message.requestIncrementalAuthorization);
    }
    if (message.authenticationData !== undefined) {
      AuthenticationData.encode(message.authenticationData, writer.uint32(234).fork()).join();
    }
    if (message.requestExtendedAuthorization !== undefined) {
      writer.uint32(240).bool(message.requestExtendedAuthorization);
    }
    if (message.minorAmount !== 0) {
      writer.uint32(248).int64(message.minorAmount);
    }
    if (message.merchantOrderReferenceId !== undefined) {
      writer.uint32(258).string(message.merchantOrderReferenceId);
    }
    if (message.shippingCost !== undefined) {
      writer.uint32(264).int64(message.shippingCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsAuthorizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsAuthorizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.paymentMethodData = PaymentMethodData.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorCustomer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = PaymentAddress.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.authType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.connectorMetaData = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accessToken = AccessToken.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.paymentMethodToken = PaymentMethodToken.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.connectorRequestReferenceId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.orderTaxAmount = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.customerName = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.captureMethod = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.returnUrl = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.completeAuthorizeUrl = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.setupFutureUsage = reader.int32() as any;
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.offSession = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.customerAcceptance = CustomerAcceptance.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.browserInfo = BrowserInformation.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.orderCategory = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.enrolledFor3ds = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.paymentExperience = reader.int32() as any;
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.paymentMethodType = reader.int32() as any;
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.requestIncrementalAuthorization = reader.bool();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.authenticationData = AuthenticationData.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.requestExtendedAuthorization = reader.bool();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.minorAmount = longToNumber(reader.int64());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.merchantOrderReferenceId = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.shippingCost = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsAuthorizeRequest {
    return {
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
      paymentMethod: isSet(object.paymentMethod) ? paymentMethodFromJSON(object.paymentMethod) : 0,
      paymentMethodData: isSet(object.paymentMethodData)
        ? PaymentMethodData.fromJSON(object.paymentMethodData)
        : undefined,
      connectorCustomer: isSet(object.connectorCustomer) ? globalThis.String(object.connectorCustomer) : undefined,
      address: isSet(object.address) ? PaymentAddress.fromJSON(object.address) : undefined,
      authType: isSet(object.authType) ? authenticationTypeFromJSON(object.authType) : 0,
      connectorMetaData: isSet(object.connectorMetaData) ? bytesFromBase64(object.connectorMetaData) : undefined,
      accessToken: isSet(object.accessToken) ? AccessToken.fromJSON(object.accessToken) : undefined,
      sessionToken: isSet(object.sessionToken) ? globalThis.String(object.sessionToken) : undefined,
      paymentMethodToken: isSet(object.paymentMethodToken)
        ? PaymentMethodToken.fromJSON(object.paymentMethodToken)
        : undefined,
      connectorRequestReferenceId: isSet(object.connectorRequestReferenceId)
        ? globalThis.String(object.connectorRequestReferenceId)
        : "",
      orderTaxAmount: isSet(object.orderTaxAmount) ? globalThis.Number(object.orderTaxAmount) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      customerName: isSet(object.customerName) ? globalThis.String(object.customerName) : undefined,
      captureMethod: isSet(object.captureMethod) ? captureMethodFromJSON(object.captureMethod) : undefined,
      returnUrl: isSet(object.returnUrl) ? globalThis.String(object.returnUrl) : undefined,
      webhookUrl: isSet(object.webhookUrl) ? globalThis.String(object.webhookUrl) : undefined,
      completeAuthorizeUrl: isSet(object.completeAuthorizeUrl)
        ? globalThis.String(object.completeAuthorizeUrl)
        : undefined,
      setupFutureUsage: isSet(object.setupFutureUsage) ? futureUsageFromJSON(object.setupFutureUsage) : undefined,
      offSession: isSet(object.offSession) ? globalThis.Boolean(object.offSession) : undefined,
      customerAcceptance: isSet(object.customerAcceptance)
        ? CustomerAcceptance.fromJSON(object.customerAcceptance)
        : undefined,
      browserInfo: isSet(object.browserInfo) ? BrowserInformation.fromJSON(object.browserInfo) : undefined,
      orderCategory: isSet(object.orderCategory) ? globalThis.String(object.orderCategory) : undefined,
      enrolledFor3ds: isSet(object.enrolledFor3ds) ? globalThis.Boolean(object.enrolledFor3ds) : false,
      paymentExperience: isSet(object.paymentExperience)
        ? paymentExperienceFromJSON(object.paymentExperience)
        : undefined,
      paymentMethodType: isSet(object.paymentMethodType)
        ? paymentMethodTypeFromJSON(object.paymentMethodType)
        : undefined,
      requestIncrementalAuthorization: isSet(object.requestIncrementalAuthorization)
        ? globalThis.Boolean(object.requestIncrementalAuthorization)
        : false,
      authenticationData: isSet(object.authenticationData)
        ? AuthenticationData.fromJSON(object.authenticationData)
        : undefined,
      requestExtendedAuthorization: isSet(object.requestExtendedAuthorization)
        ? globalThis.Boolean(object.requestExtendedAuthorization)
        : undefined,
      minorAmount: isSet(object.minorAmount) ? globalThis.Number(object.minorAmount) : 0,
      merchantOrderReferenceId: isSet(object.merchantOrderReferenceId)
        ? globalThis.String(object.merchantOrderReferenceId)
        : undefined,
      shippingCost: isSet(object.shippingCost) ? globalThis.Number(object.shippingCost) : undefined,
    };
  },

  toJSON(message: PaymentsAuthorizeRequest): unknown {
    const obj: any = {};
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.currency !== 0) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.paymentMethod !== 0) {
      obj.paymentMethod = paymentMethodToJSON(message.paymentMethod);
    }
    if (message.paymentMethodData !== undefined) {
      obj.paymentMethodData = PaymentMethodData.toJSON(message.paymentMethodData);
    }
    if (message.connectorCustomer !== undefined) {
      obj.connectorCustomer = message.connectorCustomer;
    }
    if (message.address !== undefined) {
      obj.address = PaymentAddress.toJSON(message.address);
    }
    if (message.authType !== 0) {
      obj.authType = authenticationTypeToJSON(message.authType);
    }
    if (message.connectorMetaData !== undefined) {
      obj.connectorMetaData = base64FromBytes(message.connectorMetaData);
    }
    if (message.accessToken !== undefined) {
      obj.accessToken = AccessToken.toJSON(message.accessToken);
    }
    if (message.sessionToken !== undefined) {
      obj.sessionToken = message.sessionToken;
    }
    if (message.paymentMethodToken !== undefined) {
      obj.paymentMethodToken = PaymentMethodToken.toJSON(message.paymentMethodToken);
    }
    if (message.connectorRequestReferenceId !== "") {
      obj.connectorRequestReferenceId = message.connectorRequestReferenceId;
    }
    if (message.orderTaxAmount !== undefined) {
      obj.orderTaxAmount = Math.round(message.orderTaxAmount);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.customerName !== undefined) {
      obj.customerName = message.customerName;
    }
    if (message.captureMethod !== undefined) {
      obj.captureMethod = captureMethodToJSON(message.captureMethod);
    }
    if (message.returnUrl !== undefined) {
      obj.returnUrl = message.returnUrl;
    }
    if (message.webhookUrl !== undefined) {
      obj.webhookUrl = message.webhookUrl;
    }
    if (message.completeAuthorizeUrl !== undefined) {
      obj.completeAuthorizeUrl = message.completeAuthorizeUrl;
    }
    if (message.setupFutureUsage !== undefined) {
      obj.setupFutureUsage = futureUsageToJSON(message.setupFutureUsage);
    }
    if (message.offSession !== undefined) {
      obj.offSession = message.offSession;
    }
    if (message.customerAcceptance !== undefined) {
      obj.customerAcceptance = CustomerAcceptance.toJSON(message.customerAcceptance);
    }
    if (message.browserInfo !== undefined) {
      obj.browserInfo = BrowserInformation.toJSON(message.browserInfo);
    }
    if (message.orderCategory !== undefined) {
      obj.orderCategory = message.orderCategory;
    }
    if (message.enrolledFor3ds !== false) {
      obj.enrolledFor3ds = message.enrolledFor3ds;
    }
    if (message.paymentExperience !== undefined) {
      obj.paymentExperience = paymentExperienceToJSON(message.paymentExperience);
    }
    if (message.paymentMethodType !== undefined) {
      obj.paymentMethodType = paymentMethodTypeToJSON(message.paymentMethodType);
    }
    if (message.requestIncrementalAuthorization !== false) {
      obj.requestIncrementalAuthorization = message.requestIncrementalAuthorization;
    }
    if (message.authenticationData !== undefined) {
      obj.authenticationData = AuthenticationData.toJSON(message.authenticationData);
    }
    if (message.requestExtendedAuthorization !== undefined) {
      obj.requestExtendedAuthorization = message.requestExtendedAuthorization;
    }
    if (message.minorAmount !== 0) {
      obj.minorAmount = Math.round(message.minorAmount);
    }
    if (message.merchantOrderReferenceId !== undefined) {
      obj.merchantOrderReferenceId = message.merchantOrderReferenceId;
    }
    if (message.shippingCost !== undefined) {
      obj.shippingCost = Math.round(message.shippingCost);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsAuthorizeRequest>, I>>(base?: I): PaymentsAuthorizeRequest {
    return PaymentsAuthorizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsAuthorizeRequest>, I>>(object: I): PaymentsAuthorizeRequest {
    const message = createBasePaymentsAuthorizeRequest();
    message.amount = object.amount ?? 0;
    message.currency = object.currency ?? 0;
    message.paymentMethod = object.paymentMethod ?? 0;
    message.paymentMethodData = (object.paymentMethodData !== undefined && object.paymentMethodData !== null)
      ? PaymentMethodData.fromPartial(object.paymentMethodData)
      : undefined;
    message.connectorCustomer = object.connectorCustomer ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? PaymentAddress.fromPartial(object.address)
      : undefined;
    message.authType = object.authType ?? 0;
    message.connectorMetaData = object.connectorMetaData ?? undefined;
    message.accessToken = (object.accessToken !== undefined && object.accessToken !== null)
      ? AccessToken.fromPartial(object.accessToken)
      : undefined;
    message.sessionToken = object.sessionToken ?? undefined;
    message.paymentMethodToken = (object.paymentMethodToken !== undefined && object.paymentMethodToken !== null)
      ? PaymentMethodToken.fromPartial(object.paymentMethodToken)
      : undefined;
    message.connectorRequestReferenceId = object.connectorRequestReferenceId ?? "";
    message.orderTaxAmount = object.orderTaxAmount ?? undefined;
    message.email = object.email ?? undefined;
    message.customerName = object.customerName ?? undefined;
    message.captureMethod = object.captureMethod ?? undefined;
    message.returnUrl = object.returnUrl ?? undefined;
    message.webhookUrl = object.webhookUrl ?? undefined;
    message.completeAuthorizeUrl = object.completeAuthorizeUrl ?? undefined;
    message.setupFutureUsage = object.setupFutureUsage ?? undefined;
    message.offSession = object.offSession ?? undefined;
    message.customerAcceptance = (object.customerAcceptance !== undefined && object.customerAcceptance !== null)
      ? CustomerAcceptance.fromPartial(object.customerAcceptance)
      : undefined;
    message.browserInfo = (object.browserInfo !== undefined && object.browserInfo !== null)
      ? BrowserInformation.fromPartial(object.browserInfo)
      : undefined;
    message.orderCategory = object.orderCategory ?? undefined;
    message.enrolledFor3ds = object.enrolledFor3ds ?? false;
    message.paymentExperience = object.paymentExperience ?? undefined;
    message.paymentMethodType = object.paymentMethodType ?? undefined;
    message.requestIncrementalAuthorization = object.requestIncrementalAuthorization ?? false;
    message.authenticationData = (object.authenticationData !== undefined && object.authenticationData !== null)
      ? AuthenticationData.fromPartial(object.authenticationData)
      : undefined;
    message.requestExtendedAuthorization = object.requestExtendedAuthorization ?? undefined;
    message.minorAmount = object.minorAmount ?? 0;
    message.merchantOrderReferenceId = object.merchantOrderReferenceId ?? undefined;
    message.shippingCost = object.shippingCost ?? undefined;
    return message;
  },
};

function createBasePaymentsAuthorizeResponse(): PaymentsAuthorizeResponse {
  return {
    resourceId: undefined,
    redirectionData: undefined,
    mandateReference: undefined,
    networkTxnId: undefined,
    connectorResponseReferenceId: undefined,
    incrementalAuthorizationAllowed: undefined,
    status: 0,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const PaymentsAuthorizeResponse: MessageFns<PaymentsAuthorizeResponse> = {
  encode(message: PaymentsAuthorizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== undefined) {
      ResponseId.encode(message.resourceId, writer.uint32(10).fork()).join();
    }
    if (message.redirectionData !== undefined) {
      RedirectForm.encode(message.redirectionData, writer.uint32(18).fork()).join();
    }
    if (message.mandateReference !== undefined) {
      MandateReference.encode(message.mandateReference, writer.uint32(34).fork()).join();
    }
    if (message.networkTxnId !== undefined) {
      writer.uint32(42).string(message.networkTxnId);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      writer.uint32(50).string(message.connectorResponseReferenceId);
    }
    if (message.incrementalAuthorizationAllowed !== undefined) {
      writer.uint32(56).bool(message.incrementalAuthorizationAllowed);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(74).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(82).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsAuthorizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsAuthorizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceId = ResponseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.redirectionData = RedirectForm.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mandateReference = MandateReference.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.networkTxnId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.connectorResponseReferenceId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.incrementalAuthorizationAllowed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsAuthorizeResponse {
    return {
      resourceId: isSet(object.resourceId) ? ResponseId.fromJSON(object.resourceId) : undefined,
      redirectionData: isSet(object.redirectionData) ? RedirectForm.fromJSON(object.redirectionData) : undefined,
      mandateReference: isSet(object.mandateReference) ? MandateReference.fromJSON(object.mandateReference) : undefined,
      networkTxnId: isSet(object.networkTxnId) ? globalThis.String(object.networkTxnId) : undefined,
      connectorResponseReferenceId: isSet(object.connectorResponseReferenceId)
        ? globalThis.String(object.connectorResponseReferenceId)
        : undefined,
      incrementalAuthorizationAllowed: isSet(object.incrementalAuthorizationAllowed)
        ? globalThis.Boolean(object.incrementalAuthorizationAllowed)
        : undefined,
      status: isSet(object.status) ? attemptStatusFromJSON(object.status) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: PaymentsAuthorizeResponse): unknown {
    const obj: any = {};
    if (message.resourceId !== undefined) {
      obj.resourceId = ResponseId.toJSON(message.resourceId);
    }
    if (message.redirectionData !== undefined) {
      obj.redirectionData = RedirectForm.toJSON(message.redirectionData);
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = MandateReference.toJSON(message.mandateReference);
    }
    if (message.networkTxnId !== undefined) {
      obj.networkTxnId = message.networkTxnId;
    }
    if (message.connectorResponseReferenceId !== undefined) {
      obj.connectorResponseReferenceId = message.connectorResponseReferenceId;
    }
    if (message.incrementalAuthorizationAllowed !== undefined) {
      obj.incrementalAuthorizationAllowed = message.incrementalAuthorizationAllowed;
    }
    if (message.status !== 0) {
      obj.status = attemptStatusToJSON(message.status);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsAuthorizeResponse>, I>>(base?: I): PaymentsAuthorizeResponse {
    return PaymentsAuthorizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsAuthorizeResponse>, I>>(object: I): PaymentsAuthorizeResponse {
    const message = createBasePaymentsAuthorizeResponse();
    message.resourceId = (object.resourceId !== undefined && object.resourceId !== null)
      ? ResponseId.fromPartial(object.resourceId)
      : undefined;
    message.redirectionData = (object.redirectionData !== undefined && object.redirectionData !== null)
      ? RedirectForm.fromPartial(object.redirectionData)
      : undefined;
    message.mandateReference = (object.mandateReference !== undefined && object.mandateReference !== null)
      ? MandateReference.fromPartial(object.mandateReference)
      : undefined;
    message.networkTxnId = object.networkTxnId ?? undefined;
    message.connectorResponseReferenceId = object.connectorResponseReferenceId ?? undefined;
    message.incrementalAuthorizationAllowed = object.incrementalAuthorizationAllowed ?? undefined;
    message.status = object.status ?? 0;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBasePaymentsSyncRequest(): PaymentsSyncRequest {
  return { resourceId: "", connectorRequestReferenceId: undefined };
}

export const PaymentsSyncRequest: MessageFns<PaymentsSyncRequest> = {
  encode(message: PaymentsSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== "") {
      writer.uint32(10).string(message.resourceId);
    }
    if (message.connectorRequestReferenceId !== undefined) {
      writer.uint32(18).string(message.connectorRequestReferenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsSyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectorRequestReferenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsSyncRequest {
    return {
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      connectorRequestReferenceId: isSet(object.connectorRequestReferenceId)
        ? globalThis.String(object.connectorRequestReferenceId)
        : undefined,
    };
  },

  toJSON(message: PaymentsSyncRequest): unknown {
    const obj: any = {};
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.connectorRequestReferenceId !== undefined) {
      obj.connectorRequestReferenceId = message.connectorRequestReferenceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsSyncRequest>, I>>(base?: I): PaymentsSyncRequest {
    return PaymentsSyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsSyncRequest>, I>>(object: I): PaymentsSyncRequest {
    const message = createBasePaymentsSyncRequest();
    message.resourceId = object.resourceId ?? "";
    message.connectorRequestReferenceId = object.connectorRequestReferenceId ?? undefined;
    return message;
  },
};

function createBasePaymentsSyncResponse(): PaymentsSyncResponse {
  return {
    resourceId: undefined,
    status: 0,
    mandateReference: undefined,
    networkTxnId: undefined,
    connectorResponseReferenceId: undefined,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const PaymentsSyncResponse: MessageFns<PaymentsSyncResponse> = {
  encode(message: PaymentsSyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== undefined) {
      ResponseId.encode(message.resourceId, writer.uint32(10).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.mandateReference !== undefined) {
      MandateReference.encode(message.mandateReference, writer.uint32(26).fork()).join();
    }
    if (message.networkTxnId !== undefined) {
      writer.uint32(34).string(message.networkTxnId);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      writer.uint32(42).string(message.connectorResponseReferenceId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(74).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(82).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsSyncResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceId = ResponseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mandateReference = MandateReference.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.networkTxnId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.connectorResponseReferenceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsSyncResponse {
    return {
      resourceId: isSet(object.resourceId) ? ResponseId.fromJSON(object.resourceId) : undefined,
      status: isSet(object.status) ? attemptStatusFromJSON(object.status) : 0,
      mandateReference: isSet(object.mandateReference) ? MandateReference.fromJSON(object.mandateReference) : undefined,
      networkTxnId: isSet(object.networkTxnId) ? globalThis.String(object.networkTxnId) : undefined,
      connectorResponseReferenceId: isSet(object.connectorResponseReferenceId)
        ? globalThis.String(object.connectorResponseReferenceId)
        : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: PaymentsSyncResponse): unknown {
    const obj: any = {};
    if (message.resourceId !== undefined) {
      obj.resourceId = ResponseId.toJSON(message.resourceId);
    }
    if (message.status !== 0) {
      obj.status = attemptStatusToJSON(message.status);
    }
    if (message.mandateReference !== undefined) {
      obj.mandateReference = MandateReference.toJSON(message.mandateReference);
    }
    if (message.networkTxnId !== undefined) {
      obj.networkTxnId = message.networkTxnId;
    }
    if (message.connectorResponseReferenceId !== undefined) {
      obj.connectorResponseReferenceId = message.connectorResponseReferenceId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsSyncResponse>, I>>(base?: I): PaymentsSyncResponse {
    return PaymentsSyncResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsSyncResponse>, I>>(object: I): PaymentsSyncResponse {
    const message = createBasePaymentsSyncResponse();
    message.resourceId = (object.resourceId !== undefined && object.resourceId !== null)
      ? ResponseId.fromPartial(object.resourceId)
      : undefined;
    message.status = object.status ?? 0;
    message.mandateReference = (object.mandateReference !== undefined && object.mandateReference !== null)
      ? MandateReference.fromPartial(object.mandateReference)
      : undefined;
    message.networkTxnId = object.networkTxnId ?? undefined;
    message.connectorResponseReferenceId = object.connectorResponseReferenceId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseRefundsSyncRequest(): RefundsSyncRequest {
  return { connectorRefundId: "", connectorTransactionId: "", refundReason: undefined };
}

export const RefundsSyncRequest: MessageFns<RefundsSyncRequest> = {
  encode(message: RefundsSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorRefundId !== "") {
      writer.uint32(18).string(message.connectorRefundId);
    }
    if (message.connectorTransactionId !== "") {
      writer.uint32(10).string(message.connectorTransactionId);
    }
    if (message.refundReason !== undefined) {
      writer.uint32(26).string(message.refundReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundsSyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundsSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectorRefundId = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorTransactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refundReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundsSyncRequest {
    return {
      connectorRefundId: isSet(object.connectorRefundId) ? globalThis.String(object.connectorRefundId) : "",
      connectorTransactionId: isSet(object.connectorTransactionId)
        ? globalThis.String(object.connectorTransactionId)
        : "",
      refundReason: isSet(object.refundReason) ? globalThis.String(object.refundReason) : undefined,
    };
  },

  toJSON(message: RefundsSyncRequest): unknown {
    const obj: any = {};
    if (message.connectorRefundId !== "") {
      obj.connectorRefundId = message.connectorRefundId;
    }
    if (message.connectorTransactionId !== "") {
      obj.connectorTransactionId = message.connectorTransactionId;
    }
    if (message.refundReason !== undefined) {
      obj.refundReason = message.refundReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundsSyncRequest>, I>>(base?: I): RefundsSyncRequest {
    return RefundsSyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundsSyncRequest>, I>>(object: I): RefundsSyncRequest {
    const message = createBaseRefundsSyncRequest();
    message.connectorRefundId = object.connectorRefundId ?? "";
    message.connectorTransactionId = object.connectorTransactionId ?? "";
    message.refundReason = object.refundReason ?? undefined;
    return message;
  },
};

function createBaseRefundsSyncResponse(): RefundsSyncResponse {
  return {
    connectorRefundId: undefined,
    status: 0,
    connectorResponseReferenceId: undefined,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const RefundsSyncResponse: MessageFns<RefundsSyncResponse> = {
  encode(message: RefundsSyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorRefundId !== undefined) {
      writer.uint32(10).string(message.connectorRefundId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      writer.uint32(42).string(message.connectorResponseReferenceId);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(74).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(82).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundsSyncResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundsSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorRefundId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.connectorResponseReferenceId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundsSyncResponse {
    return {
      connectorRefundId: isSet(object.connectorRefundId) ? globalThis.String(object.connectorRefundId) : undefined,
      status: isSet(object.status) ? refundStatusFromJSON(object.status) : 0,
      connectorResponseReferenceId: isSet(object.connectorResponseReferenceId)
        ? globalThis.String(object.connectorResponseReferenceId)
        : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: RefundsSyncResponse): unknown {
    const obj: any = {};
    if (message.connectorRefundId !== undefined) {
      obj.connectorRefundId = message.connectorRefundId;
    }
    if (message.status !== 0) {
      obj.status = refundStatusToJSON(message.status);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      obj.connectorResponseReferenceId = message.connectorResponseReferenceId;
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundsSyncResponse>, I>>(base?: I): RefundsSyncResponse {
    return RefundsSyncResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundsSyncResponse>, I>>(object: I): RefundsSyncResponse {
    const message = createBaseRefundsSyncResponse();
    message.connectorRefundId = object.connectorRefundId ?? undefined;
    message.status = object.status ?? 0;
    message.connectorResponseReferenceId = object.connectorResponseReferenceId ?? undefined;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBasePaymentsVoidRequest(): PaymentsVoidRequest {
  return { connectorRequestReferenceId: "", cancellationReason: undefined };
}

export const PaymentsVoidRequest: MessageFns<PaymentsVoidRequest> = {
  encode(message: PaymentsVoidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorRequestReferenceId !== "") {
      writer.uint32(18).string(message.connectorRequestReferenceId);
    }
    if (message.cancellationReason !== undefined) {
      writer.uint32(10).string(message.cancellationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsVoidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsVoidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectorRequestReferenceId = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cancellationReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsVoidRequest {
    return {
      connectorRequestReferenceId: isSet(object.connectorRequestReferenceId)
        ? globalThis.String(object.connectorRequestReferenceId)
        : "",
      cancellationReason: isSet(object.cancellationReason) ? globalThis.String(object.cancellationReason) : undefined,
    };
  },

  toJSON(message: PaymentsVoidRequest): unknown {
    const obj: any = {};
    if (message.connectorRequestReferenceId !== "") {
      obj.connectorRequestReferenceId = message.connectorRequestReferenceId;
    }
    if (message.cancellationReason !== undefined) {
      obj.cancellationReason = message.cancellationReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsVoidRequest>, I>>(base?: I): PaymentsVoidRequest {
    return PaymentsVoidRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsVoidRequest>, I>>(object: I): PaymentsVoidRequest {
    const message = createBasePaymentsVoidRequest();
    message.connectorRequestReferenceId = object.connectorRequestReferenceId ?? "";
    message.cancellationReason = object.cancellationReason ?? undefined;
    return message;
  },
};

function createBasePaymentsVoidResponse(): PaymentsVoidResponse {
  return {
    resourceId: undefined,
    connectorResponseReferenceId: undefined,
    status: 0,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const PaymentsVoidResponse: MessageFns<PaymentsVoidResponse> = {
  encode(message: PaymentsVoidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== undefined) {
      ResponseId.encode(message.resourceId, writer.uint32(10).fork()).join();
    }
    if (message.connectorResponseReferenceId !== undefined) {
      writer.uint32(26).string(message.connectorResponseReferenceId);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(34).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsVoidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsVoidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceId = ResponseId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectorResponseReferenceId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsVoidResponse {
    return {
      resourceId: isSet(object.resourceId) ? ResponseId.fromJSON(object.resourceId) : undefined,
      connectorResponseReferenceId: isSet(object.connectorResponseReferenceId)
        ? globalThis.String(object.connectorResponseReferenceId)
        : undefined,
      status: isSet(object.status) ? attemptStatusFromJSON(object.status) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: PaymentsVoidResponse): unknown {
    const obj: any = {};
    if (message.resourceId !== undefined) {
      obj.resourceId = ResponseId.toJSON(message.resourceId);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      obj.connectorResponseReferenceId = message.connectorResponseReferenceId;
    }
    if (message.status !== 0) {
      obj.status = attemptStatusToJSON(message.status);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsVoidResponse>, I>>(base?: I): PaymentsVoidResponse {
    return PaymentsVoidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsVoidResponse>, I>>(object: I): PaymentsVoidResponse {
    const message = createBasePaymentsVoidResponse();
    message.resourceId = (object.resourceId !== undefined && object.resourceId !== null)
      ? ResponseId.fromPartial(object.resourceId)
      : undefined;
    message.connectorResponseReferenceId = object.connectorResponseReferenceId ?? undefined;
    message.status = object.status ?? 0;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseIncomingWebhookRequest(): IncomingWebhookRequest {
  return { requestDetails: undefined, webhookSecrets: undefined };
}

export const IncomingWebhookRequest: MessageFns<IncomingWebhookRequest> = {
  encode(message: IncomingWebhookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestDetails !== undefined) {
      RequestDetails.encode(message.requestDetails, writer.uint32(18).fork()).join();
    }
    if (message.webhookSecrets !== undefined) {
      ConnectorWebhookSecrets.encode(message.webhookSecrets, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncomingWebhookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncomingWebhookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestDetails = RequestDetails.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.webhookSecrets = ConnectorWebhookSecrets.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncomingWebhookRequest {
    return {
      requestDetails: isSet(object.requestDetails) ? RequestDetails.fromJSON(object.requestDetails) : undefined,
      webhookSecrets: isSet(object.webhookSecrets)
        ? ConnectorWebhookSecrets.fromJSON(object.webhookSecrets)
        : undefined,
    };
  },

  toJSON(message: IncomingWebhookRequest): unknown {
    const obj: any = {};
    if (message.requestDetails !== undefined) {
      obj.requestDetails = RequestDetails.toJSON(message.requestDetails);
    }
    if (message.webhookSecrets !== undefined) {
      obj.webhookSecrets = ConnectorWebhookSecrets.toJSON(message.webhookSecrets);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncomingWebhookRequest>, I>>(base?: I): IncomingWebhookRequest {
    return IncomingWebhookRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncomingWebhookRequest>, I>>(object: I): IncomingWebhookRequest {
    const message = createBaseIncomingWebhookRequest();
    message.requestDetails = (object.requestDetails !== undefined && object.requestDetails !== null)
      ? RequestDetails.fromPartial(object.requestDetails)
      : undefined;
    message.webhookSecrets = (object.webhookSecrets !== undefined && object.webhookSecrets !== null)
      ? ConnectorWebhookSecrets.fromPartial(object.webhookSecrets)
      : undefined;
    return message;
  },
};

function createBaseIncomingWebhookResponse(): IncomingWebhookResponse {
  return { eventType: 0, content: undefined, sourceVerified: false };
}

export const IncomingWebhookResponse: MessageFns<IncomingWebhookResponse> = {
  encode(message: IncomingWebhookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.content !== undefined) {
      WebhookResponseContent.encode(message.content, writer.uint32(18).fork()).join();
    }
    if (message.sourceVerified !== false) {
      writer.uint32(24).bool(message.sourceVerified);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IncomingWebhookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIncomingWebhookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = WebhookResponseContent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sourceVerified = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IncomingWebhookResponse {
    return {
      eventType: isSet(object.eventType) ? eventTypeFromJSON(object.eventType) : 0,
      content: isSet(object.content) ? WebhookResponseContent.fromJSON(object.content) : undefined,
      sourceVerified: isSet(object.sourceVerified) ? globalThis.Boolean(object.sourceVerified) : false,
    };
  },

  toJSON(message: IncomingWebhookResponse): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = eventTypeToJSON(message.eventType);
    }
    if (message.content !== undefined) {
      obj.content = WebhookResponseContent.toJSON(message.content);
    }
    if (message.sourceVerified !== false) {
      obj.sourceVerified = message.sourceVerified;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IncomingWebhookResponse>, I>>(base?: I): IncomingWebhookResponse {
    return IncomingWebhookResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IncomingWebhookResponse>, I>>(object: I): IncomingWebhookResponse {
    const message = createBaseIncomingWebhookResponse();
    message.eventType = object.eventType ?? 0;
    message.content = (object.content !== undefined && object.content !== null)
      ? WebhookResponseContent.fromPartial(object.content)
      : undefined;
    message.sourceVerified = object.sourceVerified ?? false;
    return message;
  },
};

function createBaseWebhookResponseContent(): WebhookResponseContent {
  return { paymentsResponse: undefined, refundsResponse: undefined };
}

export const WebhookResponseContent: MessageFns<WebhookResponseContent> = {
  encode(message: WebhookResponseContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentsResponse !== undefined) {
      PaymentsSyncResponse.encode(message.paymentsResponse, writer.uint32(10).fork()).join();
    }
    if (message.refundsResponse !== undefined) {
      RefundsSyncResponse.encode(message.refundsResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookResponseContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookResponseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paymentsResponse = PaymentsSyncResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refundsResponse = RefundsSyncResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookResponseContent {
    return {
      paymentsResponse: isSet(object.paymentsResponse)
        ? PaymentsSyncResponse.fromJSON(object.paymentsResponse)
        : undefined,
      refundsResponse: isSet(object.refundsResponse) ? RefundsSyncResponse.fromJSON(object.refundsResponse) : undefined,
    };
  },

  toJSON(message: WebhookResponseContent): unknown {
    const obj: any = {};
    if (message.paymentsResponse !== undefined) {
      obj.paymentsResponse = PaymentsSyncResponse.toJSON(message.paymentsResponse);
    }
    if (message.refundsResponse !== undefined) {
      obj.refundsResponse = RefundsSyncResponse.toJSON(message.refundsResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebhookResponseContent>, I>>(base?: I): WebhookResponseContent {
    return WebhookResponseContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebhookResponseContent>, I>>(object: I): WebhookResponseContent {
    const message = createBaseWebhookResponseContent();
    message.paymentsResponse = (object.paymentsResponse !== undefined && object.paymentsResponse !== null)
      ? PaymentsSyncResponse.fromPartial(object.paymentsResponse)
      : undefined;
    message.refundsResponse = (object.refundsResponse !== undefined && object.refundsResponse !== null)
      ? RefundsSyncResponse.fromPartial(object.refundsResponse)
      : undefined;
    return message;
  },
};

function createBaseRequestDetails(): RequestDetails {
  return { method: 0, uri: undefined, headers: {}, body: new Uint8Array(0), queryParams: undefined };
}

export const RequestDetails: MessageFns<RequestDetails> = {
  encode(message: RequestDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== 0) {
      writer.uint32(8).int32(message.method);
    }
    if (message.uri !== undefined) {
      writer.uint32(18).string(message.uri);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      RequestDetails_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.queryParams !== undefined) {
      writer.uint32(42).string(message.queryParams);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = RequestDetails_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queryParams = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestDetails {
    return {
      method: isSet(object.method) ? methodFromJSON(object.method) : 0,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      queryParams: isSet(object.queryParams) ? globalThis.String(object.queryParams) : undefined,
    };
  },

  toJSON(message: RequestDetails): unknown {
    const obj: any = {};
    if (message.method !== 0) {
      obj.method = methodToJSON(message.method);
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.queryParams !== undefined) {
      obj.queryParams = message.queryParams;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestDetails>, I>>(base?: I): RequestDetails {
    return RequestDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestDetails>, I>>(object: I): RequestDetails {
    const message = createBaseRequestDetails();
    message.method = object.method ?? 0;
    message.uri = object.uri ?? undefined;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? new Uint8Array(0);
    message.queryParams = object.queryParams ?? undefined;
    return message;
  },
};

function createBaseRequestDetails_HeadersEntry(): RequestDetails_HeadersEntry {
  return { key: "", value: "" };
}

export const RequestDetails_HeadersEntry: MessageFns<RequestDetails_HeadersEntry> = {
  encode(message: RequestDetails_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestDetails_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestDetails_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestDetails_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RequestDetails_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestDetails_HeadersEntry>, I>>(base?: I): RequestDetails_HeadersEntry {
    return RequestDetails_HeadersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestDetails_HeadersEntry>, I>>(object: I): RequestDetails_HeadersEntry {
    const message = createBaseRequestDetails_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConnectorWebhookSecrets(): ConnectorWebhookSecrets {
  return { secret: "", additionalSecret: undefined };
}

export const ConnectorWebhookSecrets: MessageFns<ConnectorWebhookSecrets> = {
  encode(message: ConnectorWebhookSecrets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== "") {
      writer.uint32(10).string(message.secret);
    }
    if (message.additionalSecret !== undefined) {
      writer.uint32(18).string(message.additionalSecret);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectorWebhookSecrets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectorWebhookSecrets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.additionalSecret = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectorWebhookSecrets {
    return {
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      additionalSecret: isSet(object.additionalSecret) ? globalThis.String(object.additionalSecret) : undefined,
    };
  },

  toJSON(message: ConnectorWebhookSecrets): unknown {
    const obj: any = {};
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.additionalSecret !== undefined) {
      obj.additionalSecret = message.additionalSecret;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConnectorWebhookSecrets>, I>>(base?: I): ConnectorWebhookSecrets {
    return ConnectorWebhookSecrets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConnectorWebhookSecrets>, I>>(object: I): ConnectorWebhookSecrets {
    const message = createBaseConnectorWebhookSecrets();
    message.secret = object.secret ?? "";
    message.additionalSecret = object.additionalSecret ?? undefined;
    return message;
  },
};

function createBaseRefundsRequest(): RefundsRequest {
  return {
    refundId: "",
    connectorTransactionId: "",
    connectorRefundId: undefined,
    currency: 0,
    paymentAmount: 0,
    reason: undefined,
    webhookUrl: undefined,
    refundAmount: 0,
    connectorMetadata: undefined,
    refundConnectorMetadata: undefined,
    browserInfo: undefined,
    minorPaymentAmount: 0,
    minorRefundAmount: 0,
    merchantAccountId: undefined,
    captureMethod: undefined,
  };
}

export const RefundsRequest: MessageFns<RefundsRequest> = {
  encode(message: RefundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refundId !== "") {
      writer.uint32(10).string(message.refundId);
    }
    if (message.connectorTransactionId !== "") {
      writer.uint32(18).string(message.connectorTransactionId);
    }
    if (message.connectorRefundId !== undefined) {
      writer.uint32(26).string(message.connectorRefundId);
    }
    if (message.currency !== 0) {
      writer.uint32(120).int32(message.currency);
    }
    if (message.paymentAmount !== 0) {
      writer.uint32(32).int64(message.paymentAmount);
    }
    if (message.reason !== undefined) {
      writer.uint32(42).string(message.reason);
    }
    if (message.webhookUrl !== undefined) {
      writer.uint32(50).string(message.webhookUrl);
    }
    if (message.refundAmount !== 0) {
      writer.uint32(56).int64(message.refundAmount);
    }
    if (message.connectorMetadata !== undefined) {
      writer.uint32(66).bytes(message.connectorMetadata);
    }
    if (message.refundConnectorMetadata !== undefined) {
      writer.uint32(74).bytes(message.refundConnectorMetadata);
    }
    if (message.browserInfo !== undefined) {
      BrowserInformation.encode(message.browserInfo, writer.uint32(186).fork()).join();
    }
    if (message.minorPaymentAmount !== 0) {
      writer.uint32(80).int64(message.minorPaymentAmount);
    }
    if (message.minorRefundAmount !== 0) {
      writer.uint32(88).int64(message.minorRefundAmount);
    }
    if (message.merchantAccountId !== undefined) {
      writer.uint32(98).string(message.merchantAccountId);
    }
    if (message.captureMethod !== undefined) {
      writer.uint32(128).int32(message.captureMethod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refundId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectorTransactionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectorRefundId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.paymentAmount = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.webhookUrl = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.refundAmount = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.connectorMetadata = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.refundConnectorMetadata = reader.bytes();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.browserInfo = BrowserInformation.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.minorPaymentAmount = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.minorRefundAmount = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.merchantAccountId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.captureMethod = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundsRequest {
    return {
      refundId: isSet(object.refundId) ? globalThis.String(object.refundId) : "",
      connectorTransactionId: isSet(object.connectorTransactionId)
        ? globalThis.String(object.connectorTransactionId)
        : "",
      connectorRefundId: isSet(object.connectorRefundId) ? globalThis.String(object.connectorRefundId) : undefined,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
      paymentAmount: isSet(object.paymentAmount) ? globalThis.Number(object.paymentAmount) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
      webhookUrl: isSet(object.webhookUrl) ? globalThis.String(object.webhookUrl) : undefined,
      refundAmount: isSet(object.refundAmount) ? globalThis.Number(object.refundAmount) : 0,
      connectorMetadata: isSet(object.connectorMetadata) ? bytesFromBase64(object.connectorMetadata) : undefined,
      refundConnectorMetadata: isSet(object.refundConnectorMetadata)
        ? bytesFromBase64(object.refundConnectorMetadata)
        : undefined,
      browserInfo: isSet(object.browserInfo) ? BrowserInformation.fromJSON(object.browserInfo) : undefined,
      minorPaymentAmount: isSet(object.minorPaymentAmount) ? globalThis.Number(object.minorPaymentAmount) : 0,
      minorRefundAmount: isSet(object.minorRefundAmount) ? globalThis.Number(object.minorRefundAmount) : 0,
      merchantAccountId: isSet(object.merchantAccountId) ? globalThis.String(object.merchantAccountId) : undefined,
      captureMethod: isSet(object.captureMethod) ? captureMethodFromJSON(object.captureMethod) : undefined,
    };
  },

  toJSON(message: RefundsRequest): unknown {
    const obj: any = {};
    if (message.refundId !== "") {
      obj.refundId = message.refundId;
    }
    if (message.connectorTransactionId !== "") {
      obj.connectorTransactionId = message.connectorTransactionId;
    }
    if (message.connectorRefundId !== undefined) {
      obj.connectorRefundId = message.connectorRefundId;
    }
    if (message.currency !== 0) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.paymentAmount !== 0) {
      obj.paymentAmount = Math.round(message.paymentAmount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    if (message.webhookUrl !== undefined) {
      obj.webhookUrl = message.webhookUrl;
    }
    if (message.refundAmount !== 0) {
      obj.refundAmount = Math.round(message.refundAmount);
    }
    if (message.connectorMetadata !== undefined) {
      obj.connectorMetadata = base64FromBytes(message.connectorMetadata);
    }
    if (message.refundConnectorMetadata !== undefined) {
      obj.refundConnectorMetadata = base64FromBytes(message.refundConnectorMetadata);
    }
    if (message.browserInfo !== undefined) {
      obj.browserInfo = BrowserInformation.toJSON(message.browserInfo);
    }
    if (message.minorPaymentAmount !== 0) {
      obj.minorPaymentAmount = Math.round(message.minorPaymentAmount);
    }
    if (message.minorRefundAmount !== 0) {
      obj.minorRefundAmount = Math.round(message.minorRefundAmount);
    }
    if (message.merchantAccountId !== undefined) {
      obj.merchantAccountId = message.merchantAccountId;
    }
    if (message.captureMethod !== undefined) {
      obj.captureMethod = captureMethodToJSON(message.captureMethod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundsRequest>, I>>(base?: I): RefundsRequest {
    return RefundsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundsRequest>, I>>(object: I): RefundsRequest {
    const message = createBaseRefundsRequest();
    message.refundId = object.refundId ?? "";
    message.connectorTransactionId = object.connectorTransactionId ?? "";
    message.connectorRefundId = object.connectorRefundId ?? undefined;
    message.currency = object.currency ?? 0;
    message.paymentAmount = object.paymentAmount ?? 0;
    message.reason = object.reason ?? undefined;
    message.webhookUrl = object.webhookUrl ?? undefined;
    message.refundAmount = object.refundAmount ?? 0;
    message.connectorMetadata = object.connectorMetadata ?? undefined;
    message.refundConnectorMetadata = object.refundConnectorMetadata ?? undefined;
    message.browserInfo = (object.browserInfo !== undefined && object.browserInfo !== null)
      ? BrowserInformation.fromPartial(object.browserInfo)
      : undefined;
    message.minorPaymentAmount = object.minorPaymentAmount ?? 0;
    message.minorRefundAmount = object.minorRefundAmount ?? 0;
    message.merchantAccountId = object.merchantAccountId ?? undefined;
    message.captureMethod = object.captureMethod ?? undefined;
    return message;
  },
};

function createBaseRefundsResponse(): RefundsResponse {
  return { connectorRefundId: undefined, refundStatus: 0, errorCode: undefined, errorMessage: undefined };
}

export const RefundsResponse: MessageFns<RefundsResponse> = {
  encode(message: RefundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorRefundId !== undefined) {
      writer.uint32(10).string(message.connectorRefundId);
    }
    if (message.refundStatus !== 0) {
      writer.uint32(288).int32(message.refundStatus);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(18).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorRefundId = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }

          message.refundStatus = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefundsResponse {
    return {
      connectorRefundId: isSet(object.connectorRefundId) ? globalThis.String(object.connectorRefundId) : undefined,
      refundStatus: isSet(object.refundStatus) ? refundStatusFromJSON(object.refundStatus) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: RefundsResponse): unknown {
    const obj: any = {};
    if (message.connectorRefundId !== undefined) {
      obj.connectorRefundId = message.connectorRefundId;
    }
    if (message.refundStatus !== 0) {
      obj.refundStatus = refundStatusToJSON(message.refundStatus);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefundsResponse>, I>>(base?: I): RefundsResponse {
    return RefundsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefundsResponse>, I>>(object: I): RefundsResponse {
    const message = createBaseRefundsResponse();
    message.connectorRefundId = object.connectorRefundId ?? undefined;
    message.refundStatus = object.refundStatus ?? 0;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

function createBaseResponseId(): ResponseId {
  return { connectorTransactionId: undefined, encodedData: undefined, noResponseId: undefined };
}

export const ResponseId: MessageFns<ResponseId> = {
  encode(message: ResponseId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorTransactionId !== undefined) {
      writer.uint32(10).string(message.connectorTransactionId);
    }
    if (message.encodedData !== undefined) {
      writer.uint32(18).string(message.encodedData);
    }
    if (message.noResponseId !== undefined) {
      writer.uint32(24).bool(message.noResponseId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorTransactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encodedData = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.noResponseId = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseId {
    return {
      connectorTransactionId: isSet(object.connectorTransactionId)
        ? globalThis.String(object.connectorTransactionId)
        : undefined,
      encodedData: isSet(object.encodedData) ? globalThis.String(object.encodedData) : undefined,
      noResponseId: isSet(object.noResponseId) ? globalThis.Boolean(object.noResponseId) : undefined,
    };
  },

  toJSON(message: ResponseId): unknown {
    const obj: any = {};
    if (message.connectorTransactionId !== undefined) {
      obj.connectorTransactionId = message.connectorTransactionId;
    }
    if (message.encodedData !== undefined) {
      obj.encodedData = message.encodedData;
    }
    if (message.noResponseId !== undefined) {
      obj.noResponseId = message.noResponseId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseId>, I>>(base?: I): ResponseId {
    return ResponseId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseId>, I>>(object: I): ResponseId {
    const message = createBaseResponseId();
    message.connectorTransactionId = object.connectorTransactionId ?? undefined;
    message.encodedData = object.encodedData ?? undefined;
    message.noResponseId = object.noResponseId ?? undefined;
    return message;
  },
};

function createBaseRedirectForm(): RedirectForm {
  return { form: undefined, html: undefined };
}

export const RedirectForm: MessageFns<RedirectForm> = {
  encode(message: RedirectForm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.form !== undefined) {
      FormData.encode(message.form, writer.uint32(10).fork()).join();
    }
    if (message.html !== undefined) {
      HtmlData.encode(message.html, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedirectForm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedirectForm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.form = FormData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.html = HtmlData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedirectForm {
    return {
      form: isSet(object.form) ? FormData.fromJSON(object.form) : undefined,
      html: isSet(object.html) ? HtmlData.fromJSON(object.html) : undefined,
    };
  },

  toJSON(message: RedirectForm): unknown {
    const obj: any = {};
    if (message.form !== undefined) {
      obj.form = FormData.toJSON(message.form);
    }
    if (message.html !== undefined) {
      obj.html = HtmlData.toJSON(message.html);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RedirectForm>, I>>(base?: I): RedirectForm {
    return RedirectForm.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RedirectForm>, I>>(object: I): RedirectForm {
    const message = createBaseRedirectForm();
    message.form = (object.form !== undefined && object.form !== null) ? FormData.fromPartial(object.form) : undefined;
    message.html = (object.html !== undefined && object.html !== null) ? HtmlData.fromPartial(object.html) : undefined;
    return message;
  },
};

function createBaseFormData(): FormData {
  return { endpoint: "", method: 0, formFields: {} };
}

export const FormData: MessageFns<FormData> = {
  encode(message: FormData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    if (message.method !== 0) {
      writer.uint32(16).int32(message.method);
    }
    Object.entries(message.formFields).forEach(([key, value]) => {
      FormData_FormFieldsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FormData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = FormData_FormFieldsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.formFields[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FormData {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      method: isSet(object.method) ? methodFromJSON(object.method) : 0,
      formFields: isObject(object.formFields)
        ? Object.entries(object.formFields).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: FormData): unknown {
    const obj: any = {};
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.method !== 0) {
      obj.method = methodToJSON(message.method);
    }
    if (message.formFields) {
      const entries = Object.entries(message.formFields);
      if (entries.length > 0) {
        obj.formFields = {};
        entries.forEach(([k, v]) => {
          obj.formFields[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FormData>, I>>(base?: I): FormData {
    return FormData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FormData>, I>>(object: I): FormData {
    const message = createBaseFormData();
    message.endpoint = object.endpoint ?? "";
    message.method = object.method ?? 0;
    message.formFields = Object.entries(object.formFields ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseFormData_FormFieldsEntry(): FormData_FormFieldsEntry {
  return { key: "", value: "" };
}

export const FormData_FormFieldsEntry: MessageFns<FormData_FormFieldsEntry> = {
  encode(message: FormData_FormFieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FormData_FormFieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormData_FormFieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FormData_FormFieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FormData_FormFieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FormData_FormFieldsEntry>, I>>(base?: I): FormData_FormFieldsEntry {
    return FormData_FormFieldsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FormData_FormFieldsEntry>, I>>(object: I): FormData_FormFieldsEntry {
    const message = createBaseFormData_FormFieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHtmlData(): HtmlData {
  return { htmlData: "" };
}

export const HtmlData: MessageFns<HtmlData> = {
  encode(message: HtmlData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.htmlData !== "") {
      writer.uint32(10).string(message.htmlData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HtmlData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHtmlData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.htmlData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HtmlData {
    return { htmlData: isSet(object.htmlData) ? globalThis.String(object.htmlData) : "" };
  },

  toJSON(message: HtmlData): unknown {
    const obj: any = {};
    if (message.htmlData !== "") {
      obj.htmlData = message.htmlData;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HtmlData>, I>>(base?: I): HtmlData {
    return HtmlData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HtmlData>, I>>(object: I): HtmlData {
    const message = createBaseHtmlData();
    message.htmlData = object.htmlData ?? "";
    return message;
  },
};

function createBaseMandateReference(): MandateReference {
  return { connectorMandateId: undefined };
}

export const MandateReference: MessageFns<MandateReference> = {
  encode(message: MandateReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorMandateId !== undefined) {
      writer.uint32(10).string(message.connectorMandateId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MandateReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMandateReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorMandateId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MandateReference {
    return {
      connectorMandateId: isSet(object.connectorMandateId) ? globalThis.String(object.connectorMandateId) : undefined,
    };
  },

  toJSON(message: MandateReference): unknown {
    const obj: any = {};
    if (message.connectorMandateId !== undefined) {
      obj.connectorMandateId = message.connectorMandateId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MandateReference>, I>>(base?: I): MandateReference {
    return MandateReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MandateReference>, I>>(object: I): MandateReference {
    const message = createBaseMandateReference();
    message.connectorMandateId = object.connectorMandateId ?? undefined;
    return message;
  },
};

function createBaseCustomerAcceptance(): CustomerAcceptance {
  return { acceptanceType: 0, acceptedAt: "", online: undefined };
}

export const CustomerAcceptance: MessageFns<CustomerAcceptance> = {
  encode(message: CustomerAcceptance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceptanceType !== 0) {
      writer.uint32(8).int32(message.acceptanceType);
    }
    if (message.acceptedAt !== "") {
      writer.uint32(18).string(message.acceptedAt);
    }
    if (message.online !== undefined) {
      OnlineMandate.encode(message.online, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerAcceptance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerAcceptance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.acceptanceType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.acceptedAt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.online = OnlineMandate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerAcceptance {
    return {
      acceptanceType: isSet(object.acceptanceType) ? acceptanceTypeFromJSON(object.acceptanceType) : 0,
      acceptedAt: isSet(object.acceptedAt) ? globalThis.String(object.acceptedAt) : "",
      online: isSet(object.online) ? OnlineMandate.fromJSON(object.online) : undefined,
    };
  },

  toJSON(message: CustomerAcceptance): unknown {
    const obj: any = {};
    if (message.acceptanceType !== 0) {
      obj.acceptanceType = acceptanceTypeToJSON(message.acceptanceType);
    }
    if (message.acceptedAt !== "") {
      obj.acceptedAt = message.acceptedAt;
    }
    if (message.online !== undefined) {
      obj.online = OnlineMandate.toJSON(message.online);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CustomerAcceptance>, I>>(base?: I): CustomerAcceptance {
    return CustomerAcceptance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CustomerAcceptance>, I>>(object: I): CustomerAcceptance {
    const message = createBaseCustomerAcceptance();
    message.acceptanceType = object.acceptanceType ?? 0;
    message.acceptedAt = object.acceptedAt ?? "";
    message.online = (object.online !== undefined && object.online !== null)
      ? OnlineMandate.fromPartial(object.online)
      : undefined;
    return message;
  },
};

function createBaseBrowserInformation(): BrowserInformation {
  return {
    colorDepth: undefined,
    javaEnabled: undefined,
    javaScriptEnabled: undefined,
    language: undefined,
    screenHeight: undefined,
    screenWidth: undefined,
    timeZone: undefined,
    ipAddress: undefined,
    acceptHeader: undefined,
    userAgent: undefined,
    osType: undefined,
    osVersion: undefined,
    deviceModel: undefined,
    acceptLanguage: undefined,
  };
}

export const BrowserInformation: MessageFns<BrowserInformation> = {
  encode(message: BrowserInformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.colorDepth !== undefined) {
      writer.uint32(8).uint32(message.colorDepth);
    }
    if (message.javaEnabled !== undefined) {
      writer.uint32(16).bool(message.javaEnabled);
    }
    if (message.javaScriptEnabled !== undefined) {
      writer.uint32(24).bool(message.javaScriptEnabled);
    }
    if (message.language !== undefined) {
      writer.uint32(34).string(message.language);
    }
    if (message.screenHeight !== undefined) {
      writer.uint32(40).uint32(message.screenHeight);
    }
    if (message.screenWidth !== undefined) {
      writer.uint32(48).uint32(message.screenWidth);
    }
    if (message.timeZone !== undefined) {
      writer.uint32(56).int32(message.timeZone);
    }
    if (message.ipAddress !== undefined) {
      writer.uint32(66).string(message.ipAddress);
    }
    if (message.acceptHeader !== undefined) {
      writer.uint32(74).string(message.acceptHeader);
    }
    if (message.userAgent !== undefined) {
      writer.uint32(82).string(message.userAgent);
    }
    if (message.osType !== undefined) {
      writer.uint32(90).string(message.osType);
    }
    if (message.osVersion !== undefined) {
      writer.uint32(98).string(message.osVersion);
    }
    if (message.deviceModel !== undefined) {
      writer.uint32(106).string(message.deviceModel);
    }
    if (message.acceptLanguage !== undefined) {
      writer.uint32(114).string(message.acceptLanguage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrowserInformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrowserInformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.colorDepth = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.javaEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.javaScriptEnabled = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.screenHeight = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.screenWidth = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeZone = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.acceptHeader = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.osType = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.deviceModel = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.acceptLanguage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrowserInformation {
    return {
      colorDepth: isSet(object.colorDepth) ? globalThis.Number(object.colorDepth) : undefined,
      javaEnabled: isSet(object.javaEnabled) ? globalThis.Boolean(object.javaEnabled) : undefined,
      javaScriptEnabled: isSet(object.javaScriptEnabled) ? globalThis.Boolean(object.javaScriptEnabled) : undefined,
      language: isSet(object.language) ? globalThis.String(object.language) : undefined,
      screenHeight: isSet(object.screenHeight) ? globalThis.Number(object.screenHeight) : undefined,
      screenWidth: isSet(object.screenWidth) ? globalThis.Number(object.screenWidth) : undefined,
      timeZone: isSet(object.timeZone) ? globalThis.Number(object.timeZone) : undefined,
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      acceptHeader: isSet(object.acceptHeader) ? globalThis.String(object.acceptHeader) : undefined,
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : undefined,
      osType: isSet(object.osType) ? globalThis.String(object.osType) : undefined,
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : undefined,
      deviceModel: isSet(object.deviceModel) ? globalThis.String(object.deviceModel) : undefined,
      acceptLanguage: isSet(object.acceptLanguage) ? globalThis.String(object.acceptLanguage) : undefined,
    };
  },

  toJSON(message: BrowserInformation): unknown {
    const obj: any = {};
    if (message.colorDepth !== undefined) {
      obj.colorDepth = Math.round(message.colorDepth);
    }
    if (message.javaEnabled !== undefined) {
      obj.javaEnabled = message.javaEnabled;
    }
    if (message.javaScriptEnabled !== undefined) {
      obj.javaScriptEnabled = message.javaScriptEnabled;
    }
    if (message.language !== undefined) {
      obj.language = message.language;
    }
    if (message.screenHeight !== undefined) {
      obj.screenHeight = Math.round(message.screenHeight);
    }
    if (message.screenWidth !== undefined) {
      obj.screenWidth = Math.round(message.screenWidth);
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = Math.round(message.timeZone);
    }
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.acceptHeader !== undefined) {
      obj.acceptHeader = message.acceptHeader;
    }
    if (message.userAgent !== undefined) {
      obj.userAgent = message.userAgent;
    }
    if (message.osType !== undefined) {
      obj.osType = message.osType;
    }
    if (message.osVersion !== undefined) {
      obj.osVersion = message.osVersion;
    }
    if (message.deviceModel !== undefined) {
      obj.deviceModel = message.deviceModel;
    }
    if (message.acceptLanguage !== undefined) {
      obj.acceptLanguage = message.acceptLanguage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrowserInformation>, I>>(base?: I): BrowserInformation {
    return BrowserInformation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrowserInformation>, I>>(object: I): BrowserInformation {
    const message = createBaseBrowserInformation();
    message.colorDepth = object.colorDepth ?? undefined;
    message.javaEnabled = object.javaEnabled ?? undefined;
    message.javaScriptEnabled = object.javaScriptEnabled ?? undefined;
    message.language = object.language ?? undefined;
    message.screenHeight = object.screenHeight ?? undefined;
    message.screenWidth = object.screenWidth ?? undefined;
    message.timeZone = object.timeZone ?? undefined;
    message.ipAddress = object.ipAddress ?? undefined;
    message.acceptHeader = object.acceptHeader ?? undefined;
    message.userAgent = object.userAgent ?? undefined;
    message.osType = object.osType ?? undefined;
    message.osVersion = object.osVersion ?? undefined;
    message.deviceModel = object.deviceModel ?? undefined;
    message.acceptLanguage = object.acceptLanguage ?? undefined;
    return message;
  },
};

function createBasePaymentMethodData(): PaymentMethodData {
  return { card: undefined };
}

export const PaymentMethodData: MessageFns<PaymentMethodData> = {
  encode(message: PaymentMethodData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.card !== undefined) {
      Card.encode(message.card, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentMethodData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethodData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.card = Card.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethodData {
    return { card: isSet(object.card) ? Card.fromJSON(object.card) : undefined };
  },

  toJSON(message: PaymentMethodData): unknown {
    const obj: any = {};
    if (message.card !== undefined) {
      obj.card = Card.toJSON(message.card);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentMethodData>, I>>(base?: I): PaymentMethodData {
    return PaymentMethodData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentMethodData>, I>>(object: I): PaymentMethodData {
    const message = createBasePaymentMethodData();
    message.card = (object.card !== undefined && object.card !== null) ? Card.fromPartial(object.card) : undefined;
    return message;
  },
};

function createBaseCard(): Card {
  return {
    cardNumber: "",
    cardExpMonth: "",
    cardExpYear: "",
    cardHolderName: undefined,
    cardCvc: "",
    cardIssuer: undefined,
    cardNetwork: undefined,
    cardType: undefined,
    cardIssuingCountry: undefined,
    bankCode: undefined,
    nickName: undefined,
  };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardNumber !== "") {
      writer.uint32(10).string(message.cardNumber);
    }
    if (message.cardExpMonth !== "") {
      writer.uint32(18).string(message.cardExpMonth);
    }
    if (message.cardExpYear !== "") {
      writer.uint32(26).string(message.cardExpYear);
    }
    if (message.cardHolderName !== undefined) {
      writer.uint32(34).string(message.cardHolderName);
    }
    if (message.cardCvc !== "") {
      writer.uint32(42).string(message.cardCvc);
    }
    if (message.cardIssuer !== undefined) {
      writer.uint32(50).string(message.cardIssuer);
    }
    if (message.cardNetwork !== undefined) {
      writer.uint32(56).int32(message.cardNetwork);
    }
    if (message.cardType !== undefined) {
      writer.uint32(66).string(message.cardType);
    }
    if (message.cardIssuingCountry !== undefined) {
      writer.uint32(74).string(message.cardIssuingCountry);
    }
    if (message.bankCode !== undefined) {
      writer.uint32(82).string(message.bankCode);
    }
    if (message.nickName !== undefined) {
      writer.uint32(90).string(message.nickName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cardExpMonth = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cardExpYear = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cardHolderName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cardCvc = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cardIssuer = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cardNetwork = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cardType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.cardIssuingCountry = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.bankCode = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.nickName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      cardNumber: isSet(object.cardNumber) ? globalThis.String(object.cardNumber) : "",
      cardExpMonth: isSet(object.cardExpMonth) ? globalThis.String(object.cardExpMonth) : "",
      cardExpYear: isSet(object.cardExpYear) ? globalThis.String(object.cardExpYear) : "",
      cardHolderName: isSet(object.cardHolderName) ? globalThis.String(object.cardHolderName) : undefined,
      cardCvc: isSet(object.cardCvc) ? globalThis.String(object.cardCvc) : "",
      cardIssuer: isSet(object.cardIssuer) ? globalThis.String(object.cardIssuer) : undefined,
      cardNetwork: isSet(object.cardNetwork) ? cardNetworkFromJSON(object.cardNetwork) : undefined,
      cardType: isSet(object.cardType) ? globalThis.String(object.cardType) : undefined,
      cardIssuingCountry: isSet(object.cardIssuingCountry) ? globalThis.String(object.cardIssuingCountry) : undefined,
      bankCode: isSet(object.bankCode) ? globalThis.String(object.bankCode) : undefined,
      nickName: isSet(object.nickName) ? globalThis.String(object.nickName) : undefined,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.cardNumber !== "") {
      obj.cardNumber = message.cardNumber;
    }
    if (message.cardExpMonth !== "") {
      obj.cardExpMonth = message.cardExpMonth;
    }
    if (message.cardExpYear !== "") {
      obj.cardExpYear = message.cardExpYear;
    }
    if (message.cardHolderName !== undefined) {
      obj.cardHolderName = message.cardHolderName;
    }
    if (message.cardCvc !== "") {
      obj.cardCvc = message.cardCvc;
    }
    if (message.cardIssuer !== undefined) {
      obj.cardIssuer = message.cardIssuer;
    }
    if (message.cardNetwork !== undefined) {
      obj.cardNetwork = cardNetworkToJSON(message.cardNetwork);
    }
    if (message.cardType !== undefined) {
      obj.cardType = message.cardType;
    }
    if (message.cardIssuingCountry !== undefined) {
      obj.cardIssuingCountry = message.cardIssuingCountry;
    }
    if (message.bankCode !== undefined) {
      obj.bankCode = message.bankCode;
    }
    if (message.nickName !== undefined) {
      obj.nickName = message.nickName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Card>, I>>(base?: I): Card {
    return Card.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Card>, I>>(object: I): Card {
    const message = createBaseCard();
    message.cardNumber = object.cardNumber ?? "";
    message.cardExpMonth = object.cardExpMonth ?? "";
    message.cardExpYear = object.cardExpYear ?? "";
    message.cardHolderName = object.cardHolderName ?? undefined;
    message.cardCvc = object.cardCvc ?? "";
    message.cardIssuer = object.cardIssuer ?? undefined;
    message.cardNetwork = object.cardNetwork ?? undefined;
    message.cardType = object.cardType ?? undefined;
    message.cardIssuingCountry = object.cardIssuingCountry ?? undefined;
    message.bankCode = object.bankCode ?? undefined;
    message.nickName = object.nickName ?? undefined;
    return message;
  },
};

function createBaseOnlineMandate(): OnlineMandate {
  return { ipAddress: undefined, userAgent: "" };
}

export const OnlineMandate: MessageFns<OnlineMandate> = {
  encode(message: OnlineMandate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== undefined) {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(18).string(message.userAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OnlineMandate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOnlineMandate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OnlineMandate {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
    };
  },

  toJSON(message: OnlineMandate): unknown {
    const obj: any = {};
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OnlineMandate>, I>>(base?: I): OnlineMandate {
    return OnlineMandate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OnlineMandate>, I>>(object: I): OnlineMandate {
    const message = createBaseOnlineMandate();
    message.ipAddress = object.ipAddress ?? undefined;
    message.userAgent = object.userAgent ?? "";
    return message;
  },
};

function createBasePhoneDetails(): PhoneDetails {
  return { number: undefined, countryCode: undefined };
}

export const PhoneDetails: MessageFns<PhoneDetails> = {
  encode(message: PhoneDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== undefined) {
      writer.uint32(10).string(message.number);
    }
    if (message.countryCode !== undefined) {
      writer.uint32(18).string(message.countryCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhoneDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.number = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneDetails {
    return {
      number: isSet(object.number) ? globalThis.String(object.number) : undefined,
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : undefined,
    };
  },

  toJSON(message: PhoneDetails): unknown {
    const obj: any = {};
    if (message.number !== undefined) {
      obj.number = message.number;
    }
    if (message.countryCode !== undefined) {
      obj.countryCode = message.countryCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PhoneDetails>, I>>(base?: I): PhoneDetails {
    return PhoneDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PhoneDetails>, I>>(object: I): PhoneDetails {
    const message = createBasePhoneDetails();
    message.number = object.number ?? undefined;
    message.countryCode = object.countryCode ?? undefined;
    return message;
  },
};

function createBaseAuthenticationData(): AuthenticationData {
  return {
    eci: undefined,
    cavv: "",
    threedsServerTransactionId: undefined,
    messageVersion: undefined,
    dsTransId: undefined,
  };
}

export const AuthenticationData: MessageFns<AuthenticationData> = {
  encode(message: AuthenticationData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eci !== undefined) {
      writer.uint32(10).string(message.eci);
    }
    if (message.cavv !== "") {
      writer.uint32(18).string(message.cavv);
    }
    if (message.threedsServerTransactionId !== undefined) {
      writer.uint32(26).string(message.threedsServerTransactionId);
    }
    if (message.messageVersion !== undefined) {
      writer.uint32(34).string(message.messageVersion);
    }
    if (message.dsTransId !== undefined) {
      writer.uint32(42).string(message.dsTransId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eci = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cavv = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.threedsServerTransactionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.messageVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dsTransId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationData {
    return {
      eci: isSet(object.eci) ? globalThis.String(object.eci) : undefined,
      cavv: isSet(object.cavv) ? globalThis.String(object.cavv) : "",
      threedsServerTransactionId: isSet(object.threedsServerTransactionId)
        ? globalThis.String(object.threedsServerTransactionId)
        : undefined,
      messageVersion: isSet(object.messageVersion) ? globalThis.String(object.messageVersion) : undefined,
      dsTransId: isSet(object.dsTransId) ? globalThis.String(object.dsTransId) : undefined,
    };
  },

  toJSON(message: AuthenticationData): unknown {
    const obj: any = {};
    if (message.eci !== undefined) {
      obj.eci = message.eci;
    }
    if (message.cavv !== "") {
      obj.cavv = message.cavv;
    }
    if (message.threedsServerTransactionId !== undefined) {
      obj.threedsServerTransactionId = message.threedsServerTransactionId;
    }
    if (message.messageVersion !== undefined) {
      obj.messageVersion = message.messageVersion;
    }
    if (message.dsTransId !== undefined) {
      obj.dsTransId = message.dsTransId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationData>, I>>(base?: I): AuthenticationData {
    return AuthenticationData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationData>, I>>(object: I): AuthenticationData {
    const message = createBaseAuthenticationData();
    message.eci = object.eci ?? undefined;
    message.cavv = object.cavv ?? "";
    message.threedsServerTransactionId = object.threedsServerTransactionId ?? undefined;
    message.messageVersion = object.messageVersion ?? undefined;
    message.dsTransId = object.dsTransId ?? undefined;
    return message;
  },
};

function createBasePaymentAddress(): PaymentAddress {
  return {
    shipping: undefined,
    billing: undefined,
    unifiedPaymentMethodBilling: undefined,
    paymentMethodBilling: undefined,
  };
}

export const PaymentAddress: MessageFns<PaymentAddress> = {
  encode(message: PaymentAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shipping !== undefined) {
      Address.encode(message.shipping, writer.uint32(10).fork()).join();
    }
    if (message.billing !== undefined) {
      Address.encode(message.billing, writer.uint32(18).fork()).join();
    }
    if (message.unifiedPaymentMethodBilling !== undefined) {
      Address.encode(message.unifiedPaymentMethodBilling, writer.uint32(26).fork()).join();
    }
    if (message.paymentMethodBilling !== undefined) {
      Address.encode(message.paymentMethodBilling, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.shipping = Address.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.billing = Address.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unifiedPaymentMethodBilling = Address.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.paymentMethodBilling = Address.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentAddress {
    return {
      shipping: isSet(object.shipping) ? Address.fromJSON(object.shipping) : undefined,
      billing: isSet(object.billing) ? Address.fromJSON(object.billing) : undefined,
      unifiedPaymentMethodBilling: isSet(object.unifiedPaymentMethodBilling)
        ? Address.fromJSON(object.unifiedPaymentMethodBilling)
        : undefined,
      paymentMethodBilling: isSet(object.paymentMethodBilling)
        ? Address.fromJSON(object.paymentMethodBilling)
        : undefined,
    };
  },

  toJSON(message: PaymentAddress): unknown {
    const obj: any = {};
    if (message.shipping !== undefined) {
      obj.shipping = Address.toJSON(message.shipping);
    }
    if (message.billing !== undefined) {
      obj.billing = Address.toJSON(message.billing);
    }
    if (message.unifiedPaymentMethodBilling !== undefined) {
      obj.unifiedPaymentMethodBilling = Address.toJSON(message.unifiedPaymentMethodBilling);
    }
    if (message.paymentMethodBilling !== undefined) {
      obj.paymentMethodBilling = Address.toJSON(message.paymentMethodBilling);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentAddress>, I>>(base?: I): PaymentAddress {
    return PaymentAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentAddress>, I>>(object: I): PaymentAddress {
    const message = createBasePaymentAddress();
    message.shipping = (object.shipping !== undefined && object.shipping !== null)
      ? Address.fromPartial(object.shipping)
      : undefined;
    message.billing = (object.billing !== undefined && object.billing !== null)
      ? Address.fromPartial(object.billing)
      : undefined;
    message.unifiedPaymentMethodBilling =
      (object.unifiedPaymentMethodBilling !== undefined && object.unifiedPaymentMethodBilling !== null)
        ? Address.fromPartial(object.unifiedPaymentMethodBilling)
        : undefined;
    message.paymentMethodBilling = (object.paymentMethodBilling !== undefined && object.paymentMethodBilling !== null)
      ? Address.fromPartial(object.paymentMethodBilling)
      : undefined;
    return message;
  },
};

function createBaseAddress(): Address {
  return { address: undefined, phone: undefined, email: undefined };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      AddressDetails.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.phone !== undefined) {
      PhoneDetails.encode(message.phone, writer.uint32(18).fork()).join();
    }
    if (message.email !== undefined) {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = AddressDetails.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.phone = PhoneDetails.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      address: isSet(object.address) ? AddressDetails.fromJSON(object.address) : undefined,
      phone: isSet(object.phone) ? PhoneDetails.fromJSON(object.phone) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = AddressDetails.toJSON(message.address);
    }
    if (message.phone !== undefined) {
      obj.phone = PhoneDetails.toJSON(message.phone);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.address = (object.address !== undefined && object.address !== null)
      ? AddressDetails.fromPartial(object.address)
      : undefined;
    message.phone = (object.phone !== undefined && object.phone !== null)
      ? PhoneDetails.fromPartial(object.phone)
      : undefined;
    message.email = object.email ?? undefined;
    return message;
  },
};

function createBaseAddressDetails(): AddressDetails {
  return {
    city: undefined,
    country: undefined,
    line1: undefined,
    line2: undefined,
    line3: undefined,
    zip: undefined,
    state: undefined,
    firstName: undefined,
    lastName: undefined,
  };
}

export const AddressDetails: MessageFns<AddressDetails> = {
  encode(message: AddressDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.city !== undefined) {
      writer.uint32(10).string(message.city);
    }
    if (message.country !== undefined) {
      writer.uint32(16).int32(message.country);
    }
    if (message.line1 !== undefined) {
      writer.uint32(26).string(message.line1);
    }
    if (message.line2 !== undefined) {
      writer.uint32(34).string(message.line2);
    }
    if (message.line3 !== undefined) {
      writer.uint32(42).string(message.line3);
    }
    if (message.zip !== undefined) {
      writer.uint32(50).string(message.zip);
    }
    if (message.state !== undefined) {
      writer.uint32(58).string(message.state);
    }
    if (message.firstName !== undefined) {
      writer.uint32(66).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(74).string(message.lastName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddressDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.country = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.line1 = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.line2 = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.line3 = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.zip = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressDetails {
    return {
      city: isSet(object.city) ? globalThis.String(object.city) : undefined,
      country: isSet(object.country) ? countryAlpha2FromJSON(object.country) : undefined,
      line1: isSet(object.line1) ? globalThis.String(object.line1) : undefined,
      line2: isSet(object.line2) ? globalThis.String(object.line2) : undefined,
      line3: isSet(object.line3) ? globalThis.String(object.line3) : undefined,
      zip: isSet(object.zip) ? globalThis.String(object.zip) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
    };
  },

  toJSON(message: AddressDetails): unknown {
    const obj: any = {};
    if (message.city !== undefined) {
      obj.city = message.city;
    }
    if (message.country !== undefined) {
      obj.country = countryAlpha2ToJSON(message.country);
    }
    if (message.line1 !== undefined) {
      obj.line1 = message.line1;
    }
    if (message.line2 !== undefined) {
      obj.line2 = message.line2;
    }
    if (message.line3 !== undefined) {
      obj.line3 = message.line3;
    }
    if (message.zip !== undefined) {
      obj.zip = message.zip;
    }
    if (message.state !== undefined) {
      obj.state = message.state;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddressDetails>, I>>(base?: I): AddressDetails {
    return AddressDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddressDetails>, I>>(object: I): AddressDetails {
    const message = createBaseAddressDetails();
    message.city = object.city ?? undefined;
    message.country = object.country ?? undefined;
    message.line1 = object.line1 ?? undefined;
    message.line2 = object.line2 ?? undefined;
    message.line3 = object.line3 ?? undefined;
    message.zip = object.zip ?? undefined;
    message.state = object.state ?? undefined;
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    return message;
  },
};

function createBaseAccessToken(): AccessToken {
  return { token: "", expires: 0 };
}

export const AccessToken: MessageFns<AccessToken> = {
  encode(message: AccessToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.expires !== 0) {
      writer.uint32(16).int64(message.expires);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expires = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessToken {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
    };
  },

  toJSON(message: AccessToken): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessToken>, I>>(base?: I): AccessToken {
    return AccessToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessToken>, I>>(object: I): AccessToken {
    const message = createBaseAccessToken();
    message.token = object.token ?? "";
    message.expires = object.expires ?? 0;
    return message;
  },
};

function createBasePaymentMethodToken(): PaymentMethodToken {
  return { token: "" };
}

export const PaymentMethodToken: MessageFns<PaymentMethodToken> = {
  encode(message: PaymentMethodToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentMethodToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentMethodToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentMethodToken {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: PaymentMethodToken): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentMethodToken>, I>>(base?: I): PaymentMethodToken {
    return PaymentMethodToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentMethodToken>, I>>(object: I): PaymentMethodToken {
    const message = createBasePaymentMethodToken();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseMultipleCaptureRequestData(): MultipleCaptureRequestData {
  return { captureSequence: 0, captureReference: "" };
}

export const MultipleCaptureRequestData: MessageFns<MultipleCaptureRequestData> = {
  encode(message: MultipleCaptureRequestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.captureSequence !== 0) {
      writer.uint32(16).int64(message.captureSequence);
    }
    if (message.captureReference !== "") {
      writer.uint32(34).string(message.captureReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultipleCaptureRequestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultipleCaptureRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.captureSequence = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.captureReference = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultipleCaptureRequestData {
    return {
      captureSequence: isSet(object.captureSequence) ? globalThis.Number(object.captureSequence) : 0,
      captureReference: isSet(object.captureReference) ? globalThis.String(object.captureReference) : "",
    };
  },

  toJSON(message: MultipleCaptureRequestData): unknown {
    const obj: any = {};
    if (message.captureSequence !== 0) {
      obj.captureSequence = Math.round(message.captureSequence);
    }
    if (message.captureReference !== "") {
      obj.captureReference = message.captureReference;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultipleCaptureRequestData>, I>>(base?: I): MultipleCaptureRequestData {
    return MultipleCaptureRequestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultipleCaptureRequestData>, I>>(object: I): MultipleCaptureRequestData {
    const message = createBaseMultipleCaptureRequestData();
    message.captureSequence = object.captureSequence ?? 0;
    message.captureReference = object.captureReference ?? "";
    return message;
  },
};

function createBasePaymentsCaptureRequest(): PaymentsCaptureRequest {
  return {
    connectorTransactionId: "",
    amountToCapture: 0,
    currency: 0,
    multipleCaptureData: undefined,
    connectorMetaData: undefined,
  };
}

export const PaymentsCaptureRequest: MessageFns<PaymentsCaptureRequest> = {
  encode(message: PaymentsCaptureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectorTransactionId !== "") {
      writer.uint32(10).string(message.connectorTransactionId);
    }
    if (message.amountToCapture !== 0) {
      writer.uint32(16).int64(message.amountToCapture);
    }
    if (message.currency !== 0) {
      writer.uint32(120).int32(message.currency);
    }
    if (message.multipleCaptureData !== undefined) {
      MultipleCaptureRequestData.encode(message.multipleCaptureData, writer.uint32(170).fork()).join();
    }
    if (message.connectorMetaData !== undefined) {
      writer.uint32(26).bytes(message.connectorMetaData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsCaptureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsCaptureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectorTransactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amountToCapture = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.multipleCaptureData = MultipleCaptureRequestData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectorMetaData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsCaptureRequest {
    return {
      connectorTransactionId: isSet(object.connectorTransactionId)
        ? globalThis.String(object.connectorTransactionId)
        : "",
      amountToCapture: isSet(object.amountToCapture) ? globalThis.Number(object.amountToCapture) : 0,
      currency: isSet(object.currency) ? currencyFromJSON(object.currency) : 0,
      multipleCaptureData: isSet(object.multipleCaptureData)
        ? MultipleCaptureRequestData.fromJSON(object.multipleCaptureData)
        : undefined,
      connectorMetaData: isSet(object.connectorMetaData) ? bytesFromBase64(object.connectorMetaData) : undefined,
    };
  },

  toJSON(message: PaymentsCaptureRequest): unknown {
    const obj: any = {};
    if (message.connectorTransactionId !== "") {
      obj.connectorTransactionId = message.connectorTransactionId;
    }
    if (message.amountToCapture !== 0) {
      obj.amountToCapture = Math.round(message.amountToCapture);
    }
    if (message.currency !== 0) {
      obj.currency = currencyToJSON(message.currency);
    }
    if (message.multipleCaptureData !== undefined) {
      obj.multipleCaptureData = MultipleCaptureRequestData.toJSON(message.multipleCaptureData);
    }
    if (message.connectorMetaData !== undefined) {
      obj.connectorMetaData = base64FromBytes(message.connectorMetaData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsCaptureRequest>, I>>(base?: I): PaymentsCaptureRequest {
    return PaymentsCaptureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsCaptureRequest>, I>>(object: I): PaymentsCaptureRequest {
    const message = createBasePaymentsCaptureRequest();
    message.connectorTransactionId = object.connectorTransactionId ?? "";
    message.amountToCapture = object.amountToCapture ?? 0;
    message.currency = object.currency ?? 0;
    message.multipleCaptureData = (object.multipleCaptureData !== undefined && object.multipleCaptureData !== null)
      ? MultipleCaptureRequestData.fromPartial(object.multipleCaptureData)
      : undefined;
    message.connectorMetaData = object.connectorMetaData ?? undefined;
    return message;
  },
};

function createBasePaymentsCaptureResponse(): PaymentsCaptureResponse {
  return {
    resourceId: undefined,
    connectorResponseReferenceId: undefined,
    status: 0,
    errorCode: undefined,
    errorMessage: undefined,
  };
}

export const PaymentsCaptureResponse: MessageFns<PaymentsCaptureResponse> = {
  encode(message: PaymentsCaptureResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== undefined) {
      ResponseId.encode(message.resourceId, writer.uint32(10).fork()).join();
    }
    if (message.connectorResponseReferenceId !== undefined) {
      writer.uint32(18).string(message.connectorResponseReferenceId);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.errorCode !== undefined) {
      writer.uint32(26).string(message.errorCode);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentsCaptureResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentsCaptureResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resourceId = ResponseId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.connectorResponseReferenceId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentsCaptureResponse {
    return {
      resourceId: isSet(object.resourceId) ? ResponseId.fromJSON(object.resourceId) : undefined,
      connectorResponseReferenceId: isSet(object.connectorResponseReferenceId)
        ? globalThis.String(object.connectorResponseReferenceId)
        : undefined,
      status: isSet(object.status) ? attemptStatusFromJSON(object.status) : 0,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
    };
  },

  toJSON(message: PaymentsCaptureResponse): unknown {
    const obj: any = {};
    if (message.resourceId !== undefined) {
      obj.resourceId = ResponseId.toJSON(message.resourceId);
    }
    if (message.connectorResponseReferenceId !== undefined) {
      obj.connectorResponseReferenceId = message.connectorResponseReferenceId;
    }
    if (message.status !== 0) {
      obj.status = attemptStatusToJSON(message.status);
    }
    if (message.errorCode !== undefined) {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentsCaptureResponse>, I>>(base?: I): PaymentsCaptureResponse {
    return PaymentsCaptureResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentsCaptureResponse>, I>>(object: I): PaymentsCaptureResponse {
    const message = createBasePaymentsCaptureResponse();
    message.resourceId = (object.resourceId !== undefined && object.resourceId !== null)
      ? ResponseId.fromPartial(object.resourceId)
      : undefined;
    message.connectorResponseReferenceId = object.connectorResponseReferenceId ?? undefined;
    message.status = object.status ?? 0;
    message.errorCode = object.errorCode ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    return message;
  },
};

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  paymentAuthorize: {
    path: "/ucs.payments.PaymentService/PaymentAuthorize",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentsAuthorizeRequest) => Buffer.from(PaymentsAuthorizeRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaymentsAuthorizeRequest.decode(value),
    responseSerialize: (value: PaymentsAuthorizeResponse) =>
      Buffer.from(PaymentsAuthorizeResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentsAuthorizeResponse.decode(value),
  },
  paymentSync: {
    path: "/ucs.payments.PaymentService/PaymentSync",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentsSyncRequest) => Buffer.from(PaymentsSyncRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaymentsSyncRequest.decode(value),
    responseSerialize: (value: PaymentsSyncResponse) => Buffer.from(PaymentsSyncResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentsSyncResponse.decode(value),
  },
  refundSync: {
    path: "/ucs.payments.PaymentService/RefundSync",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefundsSyncRequest) => Buffer.from(RefundsSyncRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefundsSyncRequest.decode(value),
    responseSerialize: (value: RefundsSyncResponse) => Buffer.from(RefundsSyncResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RefundsSyncResponse.decode(value),
  },
  voidPayment: {
    path: "/ucs.payments.PaymentService/VoidPayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentsVoidRequest) => Buffer.from(PaymentsVoidRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaymentsVoidRequest.decode(value),
    responseSerialize: (value: PaymentsVoidResponse) => Buffer.from(PaymentsVoidResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentsVoidResponse.decode(value),
  },
  incomingWebhook: {
    path: "/ucs.payments.PaymentService/IncomingWebhook",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IncomingWebhookRequest) => Buffer.from(IncomingWebhookRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => IncomingWebhookRequest.decode(value),
    responseSerialize: (value: IncomingWebhookResponse) => Buffer.from(IncomingWebhookResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => IncomingWebhookResponse.decode(value),
  },
  refund: {
    path: "/ucs.payments.PaymentService/Refund",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefundsRequest) => Buffer.from(RefundsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefundsRequest.decode(value),
    responseSerialize: (value: RefundsResponse) => Buffer.from(RefundsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RefundsResponse.decode(value),
  },
  paymentCapture: {
    path: "/ucs.payments.PaymentService/PaymentCapture",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PaymentsCaptureRequest) => Buffer.from(PaymentsCaptureRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => PaymentsCaptureRequest.decode(value),
    responseSerialize: (value: PaymentsCaptureResponse) => Buffer.from(PaymentsCaptureResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentsCaptureResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  paymentAuthorize: handleUnaryCall<PaymentsAuthorizeRequest, PaymentsAuthorizeResponse>;
  paymentSync: handleUnaryCall<PaymentsSyncRequest, PaymentsSyncResponse>;
  refundSync: handleUnaryCall<RefundsSyncRequest, RefundsSyncResponse>;
  voidPayment: handleUnaryCall<PaymentsVoidRequest, PaymentsVoidResponse>;
  incomingWebhook: handleUnaryCall<IncomingWebhookRequest, IncomingWebhookResponse>;
  refund: handleUnaryCall<RefundsRequest, RefundsResponse>;
  paymentCapture: handleUnaryCall<PaymentsCaptureRequest, PaymentsCaptureResponse>;
}

export interface PaymentServiceClient extends Client {
  paymentAuthorize(
    request: PaymentsAuthorizeRequest,
    callback: (error: ServiceError | null, response: PaymentsAuthorizeResponse) => void,
  ): ClientUnaryCall;
  paymentAuthorize(
    request: PaymentsAuthorizeRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentsAuthorizeResponse) => void,
  ): ClientUnaryCall;
  paymentAuthorize(
    request: PaymentsAuthorizeRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentsAuthorizeResponse) => void,
  ): ClientUnaryCall;
  paymentSync(
    request: PaymentsSyncRequest,
    callback: (error: ServiceError | null, response: PaymentsSyncResponse) => void,
  ): ClientUnaryCall;
  paymentSync(
    request: PaymentsSyncRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentsSyncResponse) => void,
  ): ClientUnaryCall;
  paymentSync(
    request: PaymentsSyncRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentsSyncResponse) => void,
  ): ClientUnaryCall;
  refundSync(
    request: RefundsSyncRequest,
    callback: (error: ServiceError | null, response: RefundsSyncResponse) => void,
  ): ClientUnaryCall;
  refundSync(
    request: RefundsSyncRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefundsSyncResponse) => void,
  ): ClientUnaryCall;
  refundSync(
    request: RefundsSyncRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefundsSyncResponse) => void,
  ): ClientUnaryCall;
  voidPayment(
    request: PaymentsVoidRequest,
    callback: (error: ServiceError | null, response: PaymentsVoidResponse) => void,
  ): ClientUnaryCall;
  voidPayment(
    request: PaymentsVoidRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentsVoidResponse) => void,
  ): ClientUnaryCall;
  voidPayment(
    request: PaymentsVoidRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentsVoidResponse) => void,
  ): ClientUnaryCall;
  incomingWebhook(
    request: IncomingWebhookRequest,
    callback: (error: ServiceError | null, response: IncomingWebhookResponse) => void,
  ): ClientUnaryCall;
  incomingWebhook(
    request: IncomingWebhookRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IncomingWebhookResponse) => void,
  ): ClientUnaryCall;
  incomingWebhook(
    request: IncomingWebhookRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IncomingWebhookResponse) => void,
  ): ClientUnaryCall;
  refund(
    request: RefundsRequest,
    callback: (error: ServiceError | null, response: RefundsResponse) => void,
  ): ClientUnaryCall;
  refund(
    request: RefundsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RefundsResponse) => void,
  ): ClientUnaryCall;
  refund(
    request: RefundsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RefundsResponse) => void,
  ): ClientUnaryCall;
  paymentCapture(
    request: PaymentsCaptureRequest,
    callback: (error: ServiceError | null, response: PaymentsCaptureResponse) => void,
  ): ClientUnaryCall;
  paymentCapture(
    request: PaymentsCaptureRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PaymentsCaptureResponse) => void,
  ): ClientUnaryCall;
  paymentCapture(
    request: PaymentsCaptureRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PaymentsCaptureResponse) => void,
  ): ClientUnaryCall;
}

export const PaymentServiceClient = makeGenericClientConstructor(
  PaymentServiceService,
  "ucs.payments.PaymentService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PaymentServiceClient;
  service: typeof PaymentServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
